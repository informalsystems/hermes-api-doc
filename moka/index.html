<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Moka is a fast, concurrent cache library for Rust. Moka is inspired by the Caffeine library for Java."><title>moka - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="moka" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0-nightly (33a2c2487 2023-07-12)" data-channel="nightly" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../moka/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../moka/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate moka</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.11.3</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">moka</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/moka/lib.rs.html#1-222">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Moka is a fast, concurrent cache library for Rust. Moka is inspired by the
<a href="https://github.com/ben-manes/caffeine">Caffeine</a> library for Java.</p>
<p>Moka provides in-memory concurrent cache implementations on top of hash maps.
They support full concurrency of retrievals and a high expected concurrency for
updates. They utilize a lock-free concurrent hash table as the central key-value
storage.</p>
<p>All cache implementations perform a best-effort bounding of the map using an
entry replacement algorithm to determine which entries to evict when the capacity
is exceeded.</p>
<h2 id="features"><a href="#features">Features</a></h2>
<ul>
<li>Thread-safe, highly concurrent in-memory cache implementations:
<ul>
<li>Synchronous caches that can be shared across OS threads.</li>
<li>An asynchronous (futures aware) cache that can be accessed inside and
outside of asynchronous contexts.</li>
</ul>
</li>
<li>A cache can be bounded by one of the followings:
<ul>
<li>The maximum number of entries.</li>
<li>The total weighted size of entries. (Size aware eviction)</li>
</ul>
</li>
<li>Maintains good hit rate by using entry replacement algorithms inspired by
<a href="https://github.com/ben-manes/caffeine">Caffeine</a>:
<ul>
<li>Admission to a cache is controlled by the Least Frequently Used (LFU)
policy.</li>
<li>Eviction from a cache is controlled by the Least Recently Used (LRU)
policy.</li>
</ul>
</li>
<li>Supports expiration policies:
<ul>
<li>Time to live.</li>
<li>Time to idle.</li>
<li>Per-entry variable expiration.</li>
</ul>
</li>
<li>Supports eviction listener, a callback function that will be called when an
entry is removed from the cache.</li>
</ul>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<p>See the following document:</p>
<ul>
<li>Thread-safe, synchronous caches:
<ul>
<li><a href="./sync/struct.Cache.html"><code>sync::Cache</code></a></li>
<li><a href="./sync/struct.SegmentedCache.html"><code>sync::SegmentedCache</code></a></li>
</ul>
</li>
<li>An asynchronous (futures aware) cache:
<ul>
<li><a href="./future/struct.Cache.html"><code>future::Cache</code></a> (Requires “future” feature)</li>
</ul>
</li>
</ul>
<p><strong>NOTE:</strong> The following caches have been moved to a separate crate called
“<a href="https://crates.io/crates/mini-moka">mini-moka</a>”.</p>
<ul>
<li>Non concurrent cache for single threaded applications:
<ul>
<li><code>moka::unsync::Cache</code> → <a href="https://docs.rs/mini-moka/latest/mini_moka/unsync/struct.Cache.html"><code>mini_moka::unsync::Cache</code></a></li>
</ul>
</li>
<li>Experimental, thread-safe, synchronous cache:
<ul>
<li><code>moka::dash::Cache</code> → <a href="https://docs.rs/mini-moka/latest/mini_moka/sync/struct.Cache.html"><code>mini_moka::sync::Cache</code></a></li>
</ul>
</li>
</ul>
<h2 id="minimum-supported-rust-versions"><a href="#minimum-supported-rust-versions">Minimum Supported Rust Versions</a></h2>
<p>This crate’s minimum supported Rust versions (MSRV) are the followings:</p>
<div><table><thead><tr><th style="text-align: left">Feature</th><th style="text-align: center">MSRV</th></tr></thead><tbody>
<tr><td style="text-align: left">default features</td><td style="text-align: center">Rust 1.65.0 (Nov 3, 2022)</td></tr>
<tr><td style="text-align: left"><code>future</code></td><td style="text-align: center">Rust 1.65.0 (Nov 3, 2022)</td></tr>
</tbody></table>
</div>
<p>It will keep a rolling MSRV policy of at least 6 months. If only the default
features are enabled, MSRV will be updated conservatively. When using other
features, like <code>future</code>, MSRV might be updated more frequently, up to the latest
stable. In both cases, increasing MSRV is <em>not</em> considered a semver-breaking
change.</p>
<h2 id="implementation-details"><a href="#implementation-details">Implementation Details</a></h2><h3 id="concurrency"><a href="#concurrency">Concurrency</a></h3>
<p>The entry replacement algorithms are kept eventually consistent with the map.
While updates to the cache are immediately applied to the map, recording of reads
and writes may not be immediately reflected on the cache policy’s data
structures.</p>
<p>These structures are guarded by a lock and operations are applied in batches to
avoid lock contention. There are bounded inter-thread channels to hold these
operations. These channels are drained at the first opportunity when:</p>
<ul>
<li>The numbers of read/write recordings reach to the configured amounts.</li>
<li>Or, the certain time past from the last draining.</li>
</ul>
<p>In a <code>Cache</code>, this draining and batch application is handled by a single worker
thread. So under heavy concurrent operations from clients, draining may not be
able to catch up and the bounded channels can become full.</p>
<p>When read or write channel becomes full, one of the followings will occur:</p>
<ul>
<li>For the read channel, recordings of new reads will be discarded, so that
retrievals will never be blocked. This behavior may have some impact to the hit
rate of the cache.</li>
<li>For the write channel, updates from clients to the cache will be blocked until
the draining task catches up.</li>
</ul>
<p><code>Cache</code> does its best to avoid blocking updates by adjusting the interval of
draining. But since it has only one worker thread, it cannot always avoid
blocking. If this happens very often in your cache (in the future, you can check
the statistics of the cache), you may want to switch to <code>SegmentedCache</code>. It has
multiple internal cache segments and each segment has dedicated draining thread.</p>
<h3 id="admission-and-eviction"><a href="#admission-and-eviction">Admission and Eviction</a></h3>
<p>Every time a client tries to retrieve an item from the cache, that activity is
retained in a historic popularity estimator. This estimator has a tiny memory
footprint as it uses hashing to probabilistically estimate an item’s frequency.</p>
<p>All caches employ <a href="https://dl.acm.org/citation.cfm?id=3149371">TinyLFU</a> (Least Frequently Used) as the admission policy. When
a new entry is inserted to the cache, it is temporary admitted to the cache, and
a recording of this insertion is added to the write queue. When the write queue
is drained and the main space of the cache is already full, then the historic
popularity estimator determines to evict one of the following entries:</p>
<ul>
<li>The temporary admitted entry.</li>
<li>Or, an entry that is selected from the main cache space by LRU (Least Recently
Used) eviction policy.</li>
</ul>
<p>In a future release of this crate, TinyLFU admission policy will be replaced by
Window TinyLFU (W-TinyLFU) policy. W-TinyLFU has an admission window in front of
the main space. A new entry starts in the admission window and remains there as
long as it has high temporal locality (recency). Eventually an entry will slip
off from the window, then TinyLFU comes in play to determine whether or not to
admit the entry to the main space based on its popularity (frequency).</p>
<h3 id="expiration"><a href="#expiration">Expiration</a></h3>
<p>Current release supports the following cache expiration policies:</p>
<ul>
<li>The time-to-live policy</li>
<li>The time-to-idle policy</li>
<li>The variable expiration (which allows to set different expiration on each
cached entry)</li>
</ul>
<p>These policies are provided with <em>O(1)</em> time complexity:</p>
<ul>
<li>The time-to-live policy uses a write-order queue.</li>
<li>The time-to-idle policy uses an access-order queue.</li>
<li>The variable expiration will use a <a href="http://www.cs.columbia.edu/~nahum/w6998/papers/ton97-timing-wheels.pdf">hierarchical timer wheel</a>
(*1).</li>
</ul>
<p>*1: If you get 404 page not found when you click on the link to the hierarchical
timer wheel paper, try to change the URL from <code>https:</code> to <code>http:</code>.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="notification/index.html" title="mod moka::notification">notification</a><span class="stab portability" title="Available on crate features `sync` or `future` only"><code>sync</code> or <code>future</code></span></div><div class="desc docblock-short">Common data types for notifications.</div></li><li><div class="item-name"><a class="mod" href="sync/index.html" title="mod moka::sync">sync</a><span class="stab portability" title="Available on crate feature `sync` only"><code>sync</code></span></div><div class="desc docblock-short">Provides thread-safe, concurrent cache implementations.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Entry.html" title="struct moka::Entry">Entry</a><span class="stab portability" title="Available on crate features `sync` or `future` only"><code>sync</code> or <code>future</code></span></div><div class="desc docblock-short">A snapshot of a single entry in the cache.</div></li><li><div class="item-name"><a class="struct" href="struct.Policy.html" title="struct moka::Policy">Policy</a><span class="stab portability" title="Available on crate features `sync` or `future` only"><code>sync</code> or <code>future</code></span></div><div class="desc docblock-short">The policy of a cache.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.PredicateError.html" title="enum moka::PredicateError">PredicateError</a><span class="stab portability" title="Available on crate features `sync` or `future` only"><code>sync</code> or <code>future</code></span></div><div class="desc docblock-short">The error type for the functionalities around
<a href="./sync/struct.Cache.html#method.invalidate_entries_if"><code>Cache::invalidate_entries_if</code></a> method.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Expiry.html" title="trait moka::Expiry">Expiry</a><span class="stab portability" title="Available on crate features `sync` or `future` only"><code>sync</code> or <code>future</code></span></div><div class="desc docblock-short">Calculates when cache entries expire. A single expiration time is retained on
each entry so that the lifetime of an entry may be extended or reduced by
subsequent evaluations.</div></li></ul></section></div></main></body></html>