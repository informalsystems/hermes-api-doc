<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A thread-safe concurrent synchronous in-memory cache."><meta name="keywords" content="rust, rustlang, rust-lang, Cache"><title>Cache in moka::sync - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../moka/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../moka/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Cache</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.builder">builder</a></li><li><a href="#method.contains_key">contains_key</a></li><li><a href="#method.entry_count">entry_count</a></li><li><a href="#method.get">get</a></li><li><a href="#method.get_or_insert_with">get_or_insert_with</a></li><li><a href="#method.get_or_try_insert_with">get_or_try_insert_with</a></li><li><a href="#method.get_with">get_with</a></li><li><a href="#method.get_with_if">get_with_if</a></li><li><a href="#method.insert">insert</a></li><li><a href="#method.invalidate">invalidate</a></li><li><a href="#method.invalidate_all">invalidate_all</a></li><li><a href="#method.invalidate_entries_if">invalidate_entries_if</a></li><li><a href="#method.iter">iter</a></li><li><a href="#method.name">name</a></li><li><a href="#method.new">new</a></li><li><a href="#method.policy">policy</a></li><li><a href="#method.try_get_with">try_get_with</a></li><li><a href="#method.weighted_size">weighted_size</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-Clone">Clone</a></li><li><a href="#impl-ConcurrentCacheExt%3CK%2C%20V%3E">ConcurrentCacheExt&lt;K, V&gt;</a></li><li><a href="#impl-Debug">Debug</a></li><li><a href="#impl-IntoIterator">IntoIterator</a></li><li><a href="#impl-Send">Send</a></li><li><a href="#impl-Sync">Sync</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe">!UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In moka::sync</a></h2><div id="sidebar-vars" data-name="Cache" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../moka/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Struct <a href="../index.html">moka</a>::<wbr><a href="index.html">sync</a>::<wbr><a class="struct" href="#">Cache</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/moka/sync/cache.rs.html#678-681">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code>pub struct Cache&lt;K, V, S&nbsp;=&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.61.0/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt; { /* private fields */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A thread-safe concurrent synchronous in-memory cache.</p>
<p><code>Cache</code> supports full concurrency of retrievals and a high expected concurrency
for updates.</p>
<p><code>Cache</code> utilizes a lock-free concurrent hash table as the central key-value
storage. <code>Cache</code> performs a best-effort bounding of the map using an entry
replacement algorithm to determine which entries to evict when the capacity is
exceeded.</p>
<h2 id="table-of-contents"><a href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#example-insert-get-and-invalidate">Example: <code>insert</code>, <code>get</code> and <code>invalidate</code></a></li>
<li><a href="#avoiding-to-clone-the-value-at-get">Avoiding to clone the value at <code>get</code></a></li>
<li><a href="#example-size-based-eviction">Example: Size-based Eviction</a></li>
<li><a href="#example-time-based-expirations">Example: Time-based Expirations</a></li>
<li><a href="#example-eviction-listener">Example: Eviction Listener</a>
<ul>
<li><a href="#you-should-avoid-eviction-listener-to-panic">You should avoid eviction listener to panic</a></li>
<li><a href="#delivery-modes-for-eviction-listener">Delivery Modes for Eviction Listener</a>
<ul>
<li><a href="#immediate-mode"><code>Immediate</code> Mode</a></li>
<li><a href="#queued-mode"><code>Queued</code> Mode</a></li>
</ul>
</li>
<li><a href="#example-queued-delivery-mode">Example: <code>Queued</code> Delivery Mode</a></li>
</ul>
</li>
<li><a href="#thread-safety">Thread Safety</a></li>
<li><a href="#sharing-a-cache-across-threads">Sharing a cache across threads</a></li>
<li><a href="#hashing-algorithm">Hashing Algorithm</a></li>
</ul>
<h2 id="example-insert-get-and-invalidate"><a href="#example-insert-get-and-invalidate">Example: <code>insert</code>, <code>get</code> and <code>invalidate</code></a></h2>
<p>Cache entries are manually added using <a href="#method.insert"><code>insert</code></a> or
<a href="#method.get_with"><code>get_with</code></a> methods, and are stored in the cache until either
evicted or manually invalidated.</p>
<p>Here’s an example of reading and updating a cache by using multiple threads:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;

<span class="kw">use</span> <span class="ident">std::thread</span>;

<span class="kw">fn</span> <span class="ident">value</span>(<span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">String</span> {
    <span class="macro">format!</span>(<span class="string">&quot;value {}&quot;</span>, <span class="ident">n</span>)
}

<span class="kw">const</span> <span class="ident">NUM_THREADS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">16</span>;
<span class="kw">const</span> <span class="ident">NUM_KEYS_PER_THREAD</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">64</span>;

<span class="comment">// Create a cache that can store up to 10,000 entries.</span>
<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::new</span>(<span class="number">10_000</span>);

<span class="comment">// Spawn threads and read and update the cache simultaneously.</span>
<span class="kw">let</span> <span class="ident">threads</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="number">0</span>..<span class="ident">NUM_THREADS</span>)
    .<span class="ident">map</span>(<span class="op">|</span><span class="ident">i</span><span class="op">|</span> {
        <span class="comment">// To share the same cache across the threads, clone it.</span>
        <span class="comment">// This is a cheap operation.</span>
        <span class="kw">let</span> <span class="ident">my_cache</span> <span class="op">=</span> <span class="ident">cache</span>.<span class="ident">clone</span>();
        <span class="kw">let</span> <span class="ident">start</span> <span class="op">=</span> <span class="ident">i</span> <span class="op">*</span> <span class="ident">NUM_KEYS_PER_THREAD</span>;
        <span class="kw">let</span> <span class="ident">end</span> <span class="op">=</span> (<span class="ident">i</span> <span class="op">+</span> <span class="number">1</span>) <span class="op">*</span> <span class="ident">NUM_KEYS_PER_THREAD</span>;

        <span class="ident">thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
            <span class="comment">// Insert 64 entries. (NUM_KEYS_PER_THREAD = 64)</span>
            <span class="kw">for</span> <span class="ident">key</span> <span class="kw">in</span> <span class="ident">start</span>..<span class="ident">end</span> {
                <span class="ident">my_cache</span>.<span class="ident">insert</span>(<span class="ident">key</span>, <span class="ident">value</span>(<span class="ident">key</span>));
                <span class="comment">// get() returns Option&lt;String&gt;, a clone of the stored value.</span>
                <span class="macro">assert_eq!</span>(<span class="ident">my_cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>), <span class="prelude-val">Some</span>(<span class="ident">value</span>(<span class="ident">key</span>)));
            }

            <span class="comment">// Invalidate every 4 element of the inserted entries.</span>
            <span class="kw">for</span> <span class="ident">key</span> <span class="kw">in</span> (<span class="ident">start</span>..<span class="ident">end</span>).<span class="ident">step_by</span>(<span class="number">4</span>) {
                <span class="ident">my_cache</span>.<span class="ident">invalidate</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>);
            }
        })
    })
    .<span class="ident">collect</span>();

<span class="comment">// Wait for all threads to complete.</span>
<span class="ident">threads</span>.<span class="ident">into_iter</span>().<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">t</span><span class="op">|</span> <span class="ident">t</span>.<span class="ident">join</span>().<span class="ident">expect</span>(<span class="string">&quot;Failed&quot;</span>));

<span class="comment">// Verify the result.</span>
<span class="kw">for</span> <span class="ident">key</span> <span class="kw">in</span> <span class="number">0</span>..(<span class="ident">NUM_THREADS</span> <span class="op">*</span> <span class="ident">NUM_KEYS_PER_THREAD</span>) {
    <span class="kw">if</span> <span class="ident">key</span> <span class="op">%</span> <span class="number">4</span> <span class="op">==</span> <span class="number">0</span> {
        <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>), <span class="prelude-val">None</span>);
    } <span class="kw">else</span> {
        <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>), <span class="prelude-val">Some</span>(<span class="ident">value</span>(<span class="ident">key</span>)));
    }
}</code></pre></div>
<p>If you want to atomically initialize and insert a value when the key is not
present, you might want to check other insertion methods
<a href="#method.get_with"><code>get_with</code></a> and <a href="#method.try_get_with"><code>try_get_with</code></a>.</p>
<h2 id="avoiding-to-clone-the-value-at-get"><a href="#avoiding-to-clone-the-value-at-get">Avoiding to clone the value at <code>get</code></a></h2>
<p>The return type of <code>get</code> method is <code>Option&lt;V&gt;</code> instead of <code>Option&lt;&amp;V&gt;</code>. Every
time <code>get</code> is called for an existing key, it creates a clone of the stored value
<code>V</code> and returns it. This is because the <code>Cache</code> allows concurrent updates from
threads so a value stored in the cache can be dropped or replaced at any time by
any other thread. <code>get</code> cannot return a reference <code>&amp;V</code> as it is impossible to
guarantee the value outlives the reference.</p>
<p>If you want to store values that will be expensive to clone, wrap them by
<code>std::sync::Arc</code> before storing in a cache. <a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code>Arc</code></a> is a
thread-safe reference-counted pointer and its <code>clone()</code> method is cheap.</p>
<h2 id="example-size-based-eviction"><a href="#example-size-based-eviction">Example: Size-based Eviction</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::convert::TryInto</span>;
<span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;

<span class="comment">// Evict based on the number of entries in the cache.</span>
<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::builder</span>()
    <span class="comment">// Up to 10,000 entries.</span>
    .<span class="ident">max_capacity</span>(<span class="number">10_000</span>)
    <span class="comment">// Create the cache.</span>
    .<span class="ident">build</span>();
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>.<span class="ident">to_string</span>());

<span class="comment">// Evict based on the byte length of strings in the cache.</span>
<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::builder</span>()
    <span class="comment">// A weigher closure takes &amp;K and &amp;V and returns a u32</span>
    <span class="comment">// representing the relative size of the entry.</span>
    .<span class="ident">weigher</span>(<span class="op">|</span><span class="ident">_key</span>, <span class="ident">value</span>: <span class="kw-2">&amp;</span><span class="ident">String</span><span class="op">|</span> -&gt; <span class="ident">u32</span> {
        <span class="ident">value</span>.<span class="ident">len</span>().<span class="ident">try_into</span>().<span class="ident">unwrap_or</span>(<span class="ident">u32::MAX</span>)
    })
    <span class="comment">// This cache will hold up to 32MiB of values.</span>
    .<span class="ident">max_capacity</span>(<span class="number">32</span> <span class="op">*</span> <span class="number">1024</span> <span class="op">*</span> <span class="number">1024</span>)
    .<span class="ident">build</span>();
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>.<span class="ident">to_string</span>());</code></pre></div>
<p>If your cache should not grow beyond a certain size, use the <code>max_capacity</code>
method of the <a href="./struct.CacheBuilder.html"><code>CacheBuilder</code></a> to set the upper bound. The cache
will try to evict entries that have not been used recently or very often.</p>
<p>At the cache creation time, a weigher closure can be set by the <code>weigher</code> method
of the <code>CacheBuilder</code>. A weigher closure takes <code>&amp;K</code> and <code>&amp;V</code> as the arguments and
returns a <code>u32</code> representing the relative size of the entry:</p>
<ul>
<li>If the <code>weigher</code> is <em>not</em> set, the cache will treat each entry has the same
size of <code>1</code>. This means the cache will be bounded by the number of entries.</li>
<li>If the <code>weigher</code> is set, the cache will call the weigher to calculate the
weighted size (relative size) on an entry. This means the cache will be bounded
by the total weighted size of entries.</li>
</ul>
<p>Note that weighted sizes are not used when making eviction selections.</p>
<h2 id="example-time-based-expirations"><a href="#example-time-based-expirations">Example: Time-based Expirations</a></h2>
<p><code>Cache</code> supports the following expiration policies:</p>
<ul>
<li><strong>Time to live</strong>: A cached entry will be expired after the specified duration
past from <code>insert</code>.</li>
<li><strong>Time to idle</strong>: A cached entry will be expired after the specified duration
past from <code>get</code> or <code>insert</code>.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;
<span class="kw">use</span> <span class="ident">std::time::Duration</span>;

<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::builder</span>()
    <span class="comment">// Time to live (TTL): 30 minutes</span>
    .<span class="ident">time_to_live</span>(<span class="ident">Duration::from_secs</span>(<span class="number">30</span> <span class="op">*</span> <span class="number">60</span>))
    <span class="comment">// Time to idle (TTI):  5 minutes</span>
    .<span class="ident">time_to_idle</span>(<span class="ident">Duration::from_secs</span>( <span class="number">5</span> <span class="op">*</span> <span class="number">60</span>))
    <span class="comment">// Create the cache.</span>
    .<span class="ident">build</span>();

<span class="comment">// This entry will expire after 5 minutes (TTI) if there is no get().</span>
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);

<span class="comment">// This get() will extend the entry life for another 5 minutes.</span>
<span class="ident">cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="number">0</span>);

<span class="comment">// Even though we keep calling get(), the entry will expire</span>
<span class="comment">// after 30 minutes (TTL) from the insert().</span></code></pre></div>
<h2 id="example-eviction-listener"><a href="#example-eviction-listener">Example: Eviction Listener</a></h2>
<p>A <code>Cache</code> can be configured with an eviction listener, a closure that is called
every time there is a cache eviction. The listener takes three parameters: the
key and value of the evicted entry, and the
<a href="../notification/enum.RemovalCause.html"><code>RemovalCause</code></a> to indicate why the
entry was evicted.</p>
<p>An eviction listener can be used to keep other data structures in sync with the
cache, for example.</p>
<p>The following example demonstrates how to use an eviction listener with
time-to-live expiration to manage the lifecycle of temporary files on a
filesystem. The cache stores the paths of the files, and when one of them has
expired, the eviction lister will be called with the path, so it can remove the
file from the filesystem.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Cargo.toml</span>
<span class="comment">//</span>
<span class="comment">// [dependencies]</span>
<span class="comment">// anyhow = &quot;1.0&quot;</span>

<span class="kw">use</span> <span class="ident">moka</span>::{<span class="ident">sync::Cache</span>, <span class="ident">notification</span>};

<span class="kw">use</span> <span class="ident">anyhow</span>::{<span class="ident">anyhow</span>, <span class="ident">Context</span>};
<span class="kw">use</span> <span class="ident">std</span>::{
    <span class="ident">fs</span>, <span class="ident">io</span>,
    <span class="ident">path</span>::{<span class="ident">Path</span>, <span class="ident">PathBuf</span>},
    <span class="ident">sync</span>::{<span class="ident">Arc</span>, <span class="ident">RwLock</span>},
    <span class="ident">time::Duration</span>,
};

<span class="doccomment">/// The DataFileManager writes, reads and removes data files.</span>
<span class="kw">struct</span> <span class="ident">DataFileManager</span> {
    <span class="ident">base_dir</span>: <span class="ident">PathBuf</span>,
    <span class="ident">file_count</span>: <span class="ident">usize</span>,
}

<span class="kw">impl</span> <span class="ident">DataFileManager</span> {
    <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">base_dir</span>: <span class="ident">PathBuf</span>) -&gt; <span class="self">Self</span> {
        <span class="self">Self</span> {
            <span class="ident">base_dir</span>,
            <span class="ident">file_count</span>: <span class="number">0</span>,
        }
    }

    <span class="kw">fn</span> <span class="ident">write_data_file</span>(
        <span class="kw-2">&amp;mut</span> <span class="self">self</span>,
        <span class="ident">key</span>: <span class="kw">impl</span> <span class="ident">AsRef</span><span class="op">&lt;</span><span class="ident">str</span><span class="op">&gt;</span>,
        <span class="ident">contents</span>: <span class="ident">String</span>
    ) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">PathBuf</span><span class="op">&gt;</span> {
        <span class="comment">// Use the key as a part of the filename.</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">path</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">base_dir</span>.<span class="ident">to_path_buf</span>();
        <span class="ident">path</span>.<span class="ident">push</span>(<span class="ident">key</span>.<span class="ident">as_ref</span>());

        <span class="macro">assert!</span>(<span class="op">!</span><span class="ident">path</span>.<span class="ident">exists</span>(), <span class="string">&quot;Path already exists: {:?}&quot;</span>, <span class="ident">path</span>);

        <span class="comment">// create the file at the path and write the contents to the file.</span>
        <span class="ident">fs::write</span>(<span class="kw-2">&amp;</span><span class="ident">path</span>, <span class="ident">contents</span>)<span class="question-mark">?</span>;
        <span class="self">self</span>.<span class="ident">file_count</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
        <span class="macro">println!</span>(<span class="string">&quot;Created a data file at {:?} (file count: {})&quot;</span>, <span class="ident">path</span>, <span class="self">self</span>.<span class="ident">file_count</span>);
        <span class="prelude-val">Ok</span>(<span class="ident">path</span>)
    }

    <span class="kw">fn</span> <span class="ident">read_data_file</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">path</span>: <span class="kw">impl</span> <span class="ident">AsRef</span><span class="op">&lt;</span><span class="ident">Path</span><span class="op">&gt;</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span> {
        <span class="comment">// Reads the contents of the file at the path, and return the contents.</span>
        <span class="ident">fs::read_to_string</span>(<span class="ident">path</span>)
    }

    <span class="kw">fn</span> <span class="ident">remove_data_file</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">path</span>: <span class="kw">impl</span> <span class="ident">AsRef</span><span class="op">&lt;</span><span class="ident">Path</span><span class="op">&gt;</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
        <span class="comment">// Remove the file at the path.</span>
        <span class="ident">fs::remove_file</span>(<span class="ident">path</span>.<span class="ident">as_ref</span>())<span class="question-mark">?</span>;
        <span class="self">self</span>.<span class="ident">file_count</span> <span class="op">-</span><span class="op">=</span> <span class="number">1</span>;
        <span class="macro">println!</span>(
            <span class="string">&quot;Removed a data file at {:?} (file count: {})&quot;</span>,
            <span class="ident">path</span>.<span class="ident">as_ref</span>(),
            <span class="self">self</span>.<span class="ident">file_count</span>
        );

        <span class="prelude-val">Ok</span>(())
    }
}

<span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="ident">anyhow::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="comment">// Create an instance of the DataFileManager and wrap it with</span>
    <span class="comment">// Arc&lt;RwLock&lt;_&gt;&gt; so it can be shared across threads.</span>
    <span class="kw">let</span> <span class="ident">file_mgr</span> <span class="op">=</span> <span class="ident">DataFileManager::new</span>(<span class="ident">std::env::temp_dir</span>());
    <span class="kw">let</span> <span class="ident">file_mgr</span> <span class="op">=</span> <span class="ident">Arc::new</span>(<span class="ident">RwLock::new</span>(<span class="ident">file_mgr</span>));

    <span class="kw">let</span> <span class="ident">file_mgr1</span> <span class="op">=</span> <span class="ident">Arc::clone</span>(<span class="kw-2">&amp;</span><span class="ident">file_mgr</span>);

    <span class="comment">// Create an eviction lister closure.</span>
    <span class="kw">let</span> <span class="ident">listener</span> <span class="op">=</span> <span class="kw">move</span> <span class="op">|</span><span class="ident">k</span>, <span class="ident">v</span>: <span class="ident">PathBuf</span>, <span class="ident">cause</span><span class="op">|</span> {
        <span class="comment">// Try to remove the data file at the path `v`.</span>
        <span class="macro">println!</span>(
            <span class="string">&quot;\n== An entry has been evicted. k: {:?}, v: {:?}, cause: {:?}&quot;</span>,
            <span class="ident">k</span>, <span class="ident">v</span>, <span class="ident">cause</span>
        );

        <span class="comment">// Acquire the write lock of the DataFileManager. We must handle</span>
        <span class="comment">// error cases here to prevent the listener from panicking.</span>
        <span class="kw">match</span> <span class="ident">file_mgr1</span>.<span class="ident">write</span>() {
            <span class="prelude-val">Err</span>(<span class="ident">_e</span>) =&gt; {
                <span class="macro">eprintln!</span>(<span class="string">&quot;The lock has been poisoned&quot;</span>);
            }
            <span class="prelude-val">Ok</span>(<span class="kw-2">mut</span> <span class="ident">mgr</span>) =&gt; {
                <span class="comment">// Remove the data file using the DataFileManager.</span>
                <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Err</span>(<span class="ident">_e</span>) <span class="op">=</span> <span class="ident">mgr</span>.<span class="ident">remove_data_file</span>(<span class="ident">v</span>.<span class="ident">as_path</span>()) {
                    <span class="macro">eprintln!</span>(<span class="string">&quot;Failed to remove a data file at {:?}&quot;</span>, <span class="ident">v</span>);
                }
            }
        }
    };

    <span class="kw">let</span> <span class="ident">listener_conf</span> <span class="op">=</span> <span class="ident">notification::Configuration::builder</span>()
        .<span class="ident">delivery_mode</span>(<span class="ident">notification::DeliveryMode::Queued</span>)
        .<span class="ident">build</span>();

    <span class="comment">// Create the cache. Set time to live for two seconds and set the</span>
    <span class="comment">// eviction listener.</span>
    <span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::builder</span>()
        .<span class="ident">max_capacity</span>(<span class="number">100</span>)
        .<span class="ident">time_to_live</span>(<span class="ident">Duration::from_secs</span>(<span class="number">2</span>))
        .<span class="ident">eviction_listener_with_conf</span>(<span class="ident">listener</span>, <span class="ident">listener_conf</span>)
        .<span class="ident">build</span>();

    <span class="comment">// Insert an entry to the cache.</span>
    <span class="comment">// This will create and write a data file for the key &quot;user1&quot;, store the</span>
    <span class="comment">// path of the file to the cache, and return it.</span>
    <span class="macro">println!</span>(<span class="string">&quot;== try_get_with()&quot;</span>);
    <span class="kw">let</span> <span class="ident">key</span> <span class="op">=</span> <span class="string">&quot;user1&quot;</span>;
    <span class="kw">let</span> <span class="ident">path</span> <span class="op">=</span> <span class="ident">cache</span>
        .<span class="ident">try_get_with</span>(<span class="ident">key</span>, <span class="op">|</span><span class="op">|</span> -&gt; <span class="ident">anyhow::Result</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">mgr</span> <span class="op">=</span> <span class="ident">file_mgr</span>
                .<span class="ident">write</span>()
                .<span class="ident">map_err</span>(<span class="op">|</span><span class="ident">_e</span><span class="op">|</span> <span class="macro">anyhow::anyhow!</span>(<span class="string">&quot;The lock has been poisoned&quot;</span>))<span class="question-mark">?</span>;
            <span class="kw">let</span> <span class="ident">path</span> <span class="op">=</span> <span class="ident">mgr</span>
                .<span class="ident">write_data_file</span>(<span class="ident">key</span>, <span class="string">&quot;user data&quot;</span>.<span class="ident">into</span>())
                .<span class="ident">with_context</span>(<span class="op">|</span><span class="op">|</span> <span class="macro">format!</span>(<span class="string">&quot;Failed to create a data file&quot;</span>))<span class="question-mark">?</span>;
            <span class="prelude-val">Ok</span>(<span class="ident">path</span>)
        })
        .<span class="ident">map_err</span>(<span class="op">|</span><span class="ident">e</span><span class="op">|</span> <span class="macro">anyhow!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">e</span>))<span class="question-mark">?</span>;

    <span class="comment">// Read the data file at the path and print the contents.</span>
    <span class="macro">println!</span>(<span class="string">&quot;\n== read_data_file()&quot;</span>);
    {
        <span class="kw">let</span> <span class="ident">mgr</span> <span class="op">=</span> <span class="ident">file_mgr</span>
            .<span class="ident">read</span>()
            .<span class="ident">map_err</span>(<span class="op">|</span><span class="ident">_e</span><span class="op">|</span> <span class="macro">anyhow::anyhow!</span>(<span class="string">&quot;The lock has been poisoned&quot;</span>))<span class="question-mark">?</span>;
        <span class="kw">let</span> <span class="ident">contents</span> <span class="op">=</span> <span class="ident">mgr</span>
            .<span class="ident">read_data_file</span>(<span class="ident">path</span>.<span class="ident">as_path</span>())
            .<span class="ident">with_context</span>(<span class="op">|</span><span class="op">|</span> <span class="macro">format!</span>(<span class="string">&quot;Failed to read data from {:?}&quot;</span>, <span class="ident">path</span>))<span class="question-mark">?</span>;
        <span class="macro">println!</span>(<span class="string">&quot;contents: {}&quot;</span>, <span class="ident">contents</span>);
    }

    <span class="comment">// Sleep for five seconds. While sleeping, the cache entry for key &quot;user1&quot;</span>
    <span class="comment">// will be expired and evicted, so the eviction lister will be called to</span>
    <span class="comment">// remove the file.</span>
    <span class="ident">std::thread::sleep</span>(<span class="ident">Duration::from_secs</span>(<span class="number">5</span>));

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h3 id="you-should-avoid-eviction-listener-to-panic"><a href="#you-should-avoid-eviction-listener-to-panic">You should avoid eviction listener to panic</a></h3>
<p>It is very important to make an eviction listener closure not to panic.
Otherwise, the cache will stop calling the listener after a panic. This is an
intended behavior because the cache cannot know whether it is memory safe or not
to call the panicked lister again.</p>
<p>When a listener panics, the cache will swallow the panic and disable the
listener. If you want to know when a listener panics and the reason of the panic,
you can enable an optional <code>logging</code> feature of Moka and check error-level logs.</p>
<p>To enable the <code>logging</code>, do the followings:</p>
<ol>
<li>In <code>Cargo.toml</code>, add the crate feature <code>logging</code> for <code>moka</code>.</li>
<li>Set the logging level for <code>moka</code> to <code>error</code> or any lower levels (<code>warn</code>,
<code>info</code>, …):
<ul>
<li>If you are using the <code>env_logger</code> crate, you can achieve this by setting
<code>RUST_LOG</code> environment variable to <code>moka=error</code>.</li>
</ul>
</li>
<li>If you have more than one caches, you may want to set a distinct name for each
cache by using cache builder’s <a href="./struct.CacheBuilder.html#method.name"><code>name</code></a> method. The name
will appear in the log.</li>
</ol>
<h3 id="delivery-modes-for-eviction-listener"><a href="#delivery-modes-for-eviction-listener">Delivery Modes for Eviction Listener</a></h3>
<p>The <a href="../notification/enum.DeliveryMode.html"><code>DeliveryMode</code></a> specifies how and when an eviction
notifications should be delivered to an eviction listener. The <code>sync</code> caches
(<code>Cache</code> and <code>SegmentedCache</code>) support two delivery modes: <code>Immediate</code> and
<code>Queued</code> modes.</p>
<h4 id="immediate-mode"><a href="#immediate-mode"><code>Immediate</code> Mode</a></h4>
<p>Tne <code>Immediate</code> mode is the default delivery mode for the <code>sync</code> caches. Use this
mode when it is import to keep the order of write operations and eviction
notifications.</p>
<p>This mode has the following characteristics:</p>
<ul>
<li>The listener is called immediately after an entry was evicted.</li>
<li>The listener is called by the thread who evicted the entry:
<ul>
<li>The calling thread can be a background eviction thread or a user thread
invoking a cache write operation such as <code>insert</code>, <code>get_with</code> or
<code>invalidate</code>.</li>
<li>The calling thread is blocked until the listener returns.</li>
</ul>
</li>
<li>This mode guarantees that write operations and eviction notifications for a
given cache key are ordered by the time when they occurred.</li>
<li>This mode adds some performance overhead to cache write operations as it uses
internal per-key lock to guarantee the ordering.</li>
</ul>
<h4 id="queued-mode"><a href="#queued-mode"><code>Queued</code> Mode</a></h4>
<p>Use this mode when write performance is more important than preserving the order
of write operations and eviction notifications.</p>
<ul>
<li>The listener will be called some time after an entry was evicted.</li>
<li>A notification will be stashed in a queue. The queue will be processed by
dedicated notification thread(s) and that thread will call the listener.</li>
<li>This mode does not preserve the order of write operations and eviction
notifications.</li>
<li>This mode adds almost no performance overhead to cache write operations as it
does not use the per-key lock.</li>
</ul>
<h4 id="example-queued-delivery-mode"><a href="#example-queued-delivery-mode">Example: <code>Queued</code> Delivery Mode</a></h4>
<p>Because the <code>Immediate</code> mode is the default mode for <code>sync</code> caches, the previous
example was using it implicitly.</p>
<p>The following is the same example but modified for the <code>Queued</code> delivery mode.
(Showing changed lines only)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Cargo.toml</span>
<span class="comment">//</span>
<span class="comment">// [dependencies]</span>
<span class="comment">// anyhow = &quot;1.0&quot;</span>
<span class="comment">// uuid = { version = &quot;1.1&quot;, features = [&quot;v4&quot;] }</span>

<span class="kw">use</span> <span class="ident">moka</span>::{<span class="ident">sync::Cache</span>, <span class="ident">notification</span>};

<span class="comment">// Use UUID crate to generate a random file name.</span>
<span class="kw">use</span> <span class="ident">uuid::Uuid</span>;

<span class="kw">impl</span> <span class="ident">DataFileManager</span> {
    <span class="kw">fn</span> <span class="ident">write_data_file</span>(
        <span class="kw-2">&amp;mut</span> <span class="self">self</span>,
        <span class="ident">_key</span>: <span class="kw">impl</span> <span class="ident">AsRef</span><span class="op">&lt;</span><span class="ident">str</span><span class="op">&gt;</span>,
        <span class="ident">contents</span>: <span class="ident">String</span>
    ) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">PathBuf</span><span class="op">&gt;</span> {
        <span class="comment">// We do not use the key for the filename anymore. Instead, we</span>
        <span class="comment">// use UUID to generate a unique filename for each call.</span>
        <span class="kw">loop</span> {
            <span class="comment">// Generate a file path with unique file name.</span>
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">path</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">base_dir</span>.<span class="ident">to_path_buf</span>();
            <span class="ident">path</span>.<span class="ident">push</span>(<span class="ident">Uuid::new_v4</span>().<span class="ident">as_hyphenated</span>().<span class="ident">to_string</span>());

            <span class="kw">if</span> <span class="ident">path</span>.<span class="ident">exists</span>() {
                <span class="kw">continue</span>; <span class="comment">// This path is already taken by others. Retry.</span>
            }

            <span class="comment">// We have got a unique file path, so create the file at</span>
            <span class="comment">// the path and write the contents to the file.</span>
            <span class="ident">fs::write</span>(<span class="kw-2">&amp;</span><span class="ident">path</span>, <span class="ident">contents</span>)<span class="question-mark">?</span>;
            <span class="self">self</span>.<span class="ident">file_count</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
            <span class="macro">println!</span>(<span class="string">&quot;Created a data file at {:?} (file count: {})&quot;</span>, <span class="ident">path</span>, <span class="self">self</span>.<span class="ident">file_count</span>);

            <span class="comment">// Return the path.</span>
            <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">path</span>);
        }
    }

    <span class="comment">// Other associate functions and methods are unchanged.</span>
}

<span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="ident">anyhow::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="comment">// (Omitted unchanged lines)</span>

    <span class="comment">// Create an eviction lister closure.</span>
    <span class="comment">// let listener = ...</span>

    <span class="comment">// Create a listener configuration with Queued delivery mode.</span>
    <span class="kw">let</span> <span class="ident">listener_conf</span> <span class="op">=</span> <span class="ident">notification::Configuration::builder</span>()
        .<span class="ident">delivery_mode</span>(<span class="ident">notification::DeliveryMode::Queued</span>)
        .<span class="ident">build</span>();

    <span class="comment">// Create the cache.</span>
    <span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::builder</span>()
        .<span class="ident">max_capacity</span>(<span class="number">100</span>)
        .<span class="ident">time_to_live</span>(<span class="ident">Duration::from_secs</span>(<span class="number">2</span>))
        <span class="comment">// Set the eviction listener with the configuration.</span>
        .<span class="ident">eviction_listener_with_conf</span>(<span class="ident">listener</span>, <span class="ident">listener_conf</span>)
        .<span class="ident">build</span>();

    <span class="comment">// Insert an entry to the cache.</span>
    <span class="comment">// ...</span>
    <span class="comment">// Read the data file at the path and print the contents.</span>
    <span class="comment">// ...</span>
    <span class="comment">// Sleep for five seconds.</span>
    <span class="comment">// ...</span>

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>As you can see, <code>DataFileManager::write_data_file</code> method no longer uses the
cache key for the file name. Instead, it generates a UUID-based unique file name
on each call. This kind of treatment will be needed for <code>Queued</code> mode because
notifications will be delivered with some delay.</p>
<p>For example, a user thread could do the followings:</p>
<ol>
<li><code>insert</code> an entry, and create a file.</li>
<li>The entry is evicted due to size constraint:
<ul>
<li>This will trigger an eviction notification but it will be fired some time
later.</li>
<li>The notification listener will remove the file when it is called, but we
cannot predict when the call would be made.</li>
</ul>
</li>
<li><code>insert</code> the entry again, and create the file again.</li>
</ol>
<p>In <code>Queued</code> mode, the notification of the eviction at step 2 can be delivered
either before or after the re-<code>insert</code> at step 3. If the <code>write_data_file</code> method
does not generate unique file name on each call and the notification has not been
delivered before step 3, the user thread could overwrite the file created at
step 1. And then the notification will be delivered and the eviction listener
will remove a wrong file created at step 3 (instead of the correct one created at
step 1). This will cause the cache entires and the files on the filesystem to
become out of sync.</p>
<p>Generating unique file names prevents this problem, as the user thread will never
overwrite the file created at step 1 and the eviction lister will never remove a
wrong file.</p>
<h2 id="thread-safety"><a href="#thread-safety">Thread Safety</a></h2>
<p>All methods provided by the <code>Cache</code> are considered thread-safe, and can be safely
accessed by multiple concurrent threads.</p>
<ul>
<li><code>Cache&lt;K, V, S&gt;</code> requires trait bounds <code>Send</code>, <code>Sync</code> and <code>'static</code> for <code>K</code>
(key), <code>V</code> (value) and <code>S</code> (hasher state).</li>
<li><code>Cache&lt;K, V, S&gt;</code> will implement <code>Send</code> and <code>Sync</code>.</li>
</ul>
<h2 id="sharing-a-cache-across-threads"><a href="#sharing-a-cache-across-threads">Sharing a cache across threads</a></h2>
<p>To share a cache across threads, do one of the followings:</p>
<ul>
<li>Create a clone of the cache by calling its <code>clone</code> method and pass it to other
thread.</li>
<li>Wrap the cache by a <code>sync::OnceCell</code> or <code>sync::Lazy</code> from
<a href="https://crates.io/crates/once_cell">once_cell</a> create, and set it to a <code>static</code> variable.</li>
</ul>
<p>Cloning is a cheap operation for <code>Cache</code> as it only creates thread-safe
reference-counted pointers to the internal data structures.</p>
<h2 id="hashing-algorithm"><a href="#hashing-algorithm">Hashing Algorithm</a></h2>
<p>By default, <code>Cache</code> uses a hashing algorithm selected to provide resistance
against HashDoS attacks. It will be the same one used by
<code>std::collections::HashMap</code>, which is currently SipHash 1-3.</p>
<p>While SipHash’s performance is very competitive for medium sized keys, other
hashing algorithms will outperform it for small keys such as integers as well as
large keys such as long strings. However those algorithms will typically not
protect against attacks such as HashDoS.</p>
<p>The hashing algorithm can be replaced on a per-<code>Cache</code> basis using the
<a href="./struct.CacheBuilder.html#method.build_with_hasher"><code>build_with_hasher</code></a> method of the <code>CacheBuilder</code>.
Many alternative algorithms are available on crates.io, such as the
<a href="https://crates.io/crates/ahash">aHash</a> crate.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#733-795">source</a></span><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.name" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#735-737">source</a></span><a href="#method.name" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.name" class="fnname">name</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.61.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Returns cache’s name.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.policy" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#743-745">source</a></span><a href="#method.policy" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.policy" class="fnname">policy</a>(&amp;self) -&gt; <a class="struct" href="../struct.Policy.html" title="struct moka::Policy">Policy</a></h4></section></summary><div class="docblock"><p>Returns a read-only cache policy of this cache.</p>
<p>At this time, cache policy cannot be modified after cache creation.
A future version may support to modify it.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.entry_count" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#782-784">source</a></span><a href="#method.entry_count" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.entry_count" class="fnname">entry_count</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.u64.html">u64</a></h4></section></summary><div class="docblock"><p>Returns an approximate number of entries in this cache.</p>
<p>The value returned is <em>an estimate</em>; the actual count may differ if there are
concurrent insertions or removals, or if some entries are pending removal due
to expiration. This inaccuracy can be mitigated by performing a <code>sync()</code>
first.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;

<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::new</span>(<span class="number">10</span>);
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="string">&#39;n&#39;</span>, <span class="string">&quot;Netherland Dwarf&quot;</span>);
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="string">&#39;l&#39;</span>, <span class="string">&quot;Lop Eared&quot;</span>);
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="string">&#39;d&#39;</span>, <span class="string">&quot;Dutch&quot;</span>);

<span class="comment">// Ensure an entry exists.</span>
<span class="macro">assert!</span>(<span class="ident">cache</span>.<span class="ident">contains_key</span>(<span class="kw-2">&amp;</span><span class="string">&#39;n&#39;</span>));

<span class="comment">// However, followings may print stale number zeros instead of threes.</span>
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">cache</span>.<span class="ident">entry_count</span>());   <span class="comment">// -&gt; 0</span>
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">cache</span>.<span class="ident">weighted_size</span>()); <span class="comment">// -&gt; 0</span>

<span class="comment">// To mitigate the inaccuracy, bring `ConcurrentCacheExt` trait to</span>
<span class="comment">// the scope so we can use `sync` method.</span>
<span class="kw">use</span> <span class="ident">moka::sync::ConcurrentCacheExt</span>;
<span class="comment">// Call `sync` to run pending internal tasks.</span>
<span class="ident">cache</span>.<span class="ident">sync</span>();

<span class="comment">// Followings will print the actual numbers.</span>
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">cache</span>.<span class="ident">entry_count</span>());   <span class="comment">// -&gt; 3</span>
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">cache</span>.<span class="ident">weighted_size</span>()); <span class="comment">// -&gt; 3</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.weighted_size" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#792-794">source</a></span><a href="#method.weighted_size" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.weighted_size" class="fnname">weighted_size</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.u64.html">u64</a></h4></section></summary><div class="docblock"><p>Returns an approximate total weighted size of entries in this cache.</p>
<p>The value returned is <em>an estimate</em>; the actual size may differ if there are
concurrent insertions or removals, or if some entries are pending removal due
to expiration. This inaccuracy can be mitigated by performing a <code>sync()</code>
first. See <a href="#method.entry_count"><code>entry_count</code></a> for a sample code.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#797-831">source</a></span><a href="#impl-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V&gt; <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, <a class="struct" href="https://doc.rust-lang.org/1.61.0/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#808-822">source</a></span><a href="#method.new" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>(max_capacity: <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.u64.html">u64</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a new <code>Cache&lt;K, V&gt;</code> that will store up to the <code>max_capacity</code>.</p>
<p>To adjust various configuration knobs such as <code>initial_capacity</code> or
<code>time_to_live</code>, use the <a href="./struct.CacheBuilder.html"><code>CacheBuilder</code></a>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.builder" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#828-830">source</a></span><a href="#method.builder" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.builder" class="fnname">builder</a>() -&gt; <a class="struct" href="struct.CacheBuilder.html" title="struct moka::sync::CacheBuilder">CacheBuilder</a>&lt;K, V, <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, <a class="struct" href="https://doc.rust-lang.org/1.61.0/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a <a href="./struct.CacheBuilder.html"><code>CacheBuilder</code></a>, which can builds a <code>Cache</code> or
<code>SegmentedCache</code> with various configuration knobs.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-2" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#833-1361">source</a></span><a href="#impl-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.contains_key" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#878-884">source</a></span><a href="#method.contains_key" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.contains_key" class="fnname">contains_key</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;</a>Q) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.61.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;K&gt;: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;Q: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the cache contains a value for the key.</p>
<p>Unlike the <code>get</code> method, this method is not considered a cache read operation,
so it does not update the historic popularity estimator or reset the idle
timer for the key.</p>
<p>The key may be any borrowed form of the cache’s key type, but <code>Hash</code> and <code>Eq</code>
on the borrowed form <em>must</em> match those for the key type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#904-910">source</a></span><a href="#method.get" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get" class="fnname">get</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;</a>Q) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.61.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.61.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;K&gt;: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;Q: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns a <em>clone</em> of the value corresponding to the key.</p>
<p>If you want to store values that will be expensive to clone, wrap them by
<code>std::sync::Arc</code> before storing in a cache. <a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code>Arc</code></a> is a
thread-safe reference-counted pointer and its <code>clone()</code> method is cheap.</p>
<p>The key may be any borrowed form of the cache’s key type, but <code>Hash</code> and <code>Eq</code>
on the borrowed form <em>must</em> match those for the key type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_or_insert_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#922-924">source</a></span><a href="#method.get_or_insert_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_or_insert_with" class="fnname">get_or_insert_with</a>(&amp;self, key: K, init: impl <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; V) -&gt; V</h4></section><div class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated since 0.8.0: <p>Replaced with <code>get_with</code></p>
</div></div></summary><div class="docblock"><p>Deprecated, replaced with <a href="#method.get_with"><code>get_with</code></a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_or_try_insert_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#928-934">source</a></span><a href="#method.get_or_try_insert_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_or_try_insert_with" class="fnname">get_or_try_insert_with</a>&lt;F, E&gt;(&amp;self, key: K, init: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.61.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;V, <a class="struct" href="https://doc.rust-lang.org/1.61.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;E&gt;&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/1.61.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;V, E&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;E: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h4></section><div class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated since 0.8.0: <p>Replaced with <code>try_get_with</code></p>
</div></div></summary><div class="docblock"><p>Deprecated, replaced with <a href="#method.try_get_with"><code>try_get_with</code></a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#1009-1014">source</a></span><a href="#method.get_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_with" class="fnname">get_with</a>(&amp;self, key: K, init: impl <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; V) -&gt; V</h4></section></summary><div class="docblock"><p>Ensures the value of the key exists by inserting the output of the <code>init</code>
closure if not exist, and returns a <em>clone</em> of the value.</p>
<p>This method prevents to evaluate the <code>init</code> closure multiple times on the
same key even if the method is concurrently called by many threads; only one
of the calls evaluates its closure, and other calls wait for that closure to
complete.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">sync::Arc</span>, <span class="ident">thread</span>, <span class="ident">time::Duration</span>};

<span class="kw">const</span> <span class="ident">TEN_MIB</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">10</span> <span class="op">*</span> <span class="number">1024</span> <span class="op">*</span> <span class="number">1024</span>; <span class="comment">// 10MiB</span>
<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::new</span>(<span class="number">100</span>);

<span class="comment">// Spawn four threads.</span>
<span class="kw">let</span> <span class="ident">threads</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="number">0</span>..<span class="number">4_u8</span>)
    .<span class="ident">map</span>(<span class="op">|</span><span class="ident">task_id</span><span class="op">|</span> {
        <span class="kw">let</span> <span class="ident">my_cache</span> <span class="op">=</span> <span class="ident">cache</span>.<span class="ident">clone</span>();
        <span class="ident">thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
            <span class="macro">println!</span>(<span class="string">&quot;Thread {} started.&quot;</span>, <span class="ident">task_id</span>);

            <span class="comment">// Try to insert and get the value for key1. Although all four</span>
            <span class="comment">// threads will call `get_with` at the same time, the `init` closure</span>
            <span class="comment">// must be evaluated only once.</span>
            <span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">my_cache</span>.<span class="ident">get_with</span>(<span class="string">&quot;key1&quot;</span>, <span class="op">|</span><span class="op">|</span> {
                <span class="macro">println!</span>(<span class="string">&quot;Thread {} inserting a value.&quot;</span>, <span class="ident">task_id</span>);
                <span class="ident">Arc::new</span>(<span class="macro">vec!</span>[<span class="number">0u8</span>; <span class="ident">TEN_MIB</span>])
            });

            <span class="comment">// Ensure the value exists now.</span>
            <span class="macro">assert_eq!</span>(<span class="ident">value</span>.<span class="ident">len</span>(), <span class="ident">TEN_MIB</span>);
            <span class="ident">thread::sleep</span>(<span class="ident">Duration::from_millis</span>(<span class="number">10</span>));
            <span class="macro">assert!</span>(<span class="ident">my_cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="string">&quot;key1&quot;</span>).<span class="ident">is_some</span>());

            <span class="macro">println!</span>(<span class="string">&quot;Thread {} got the value. (len: {})&quot;</span>, <span class="ident">task_id</span>, <span class="ident">value</span>.<span class="ident">len</span>());
        })
    })
    .<span class="ident">collect</span>();

<span class="comment">// Wait all threads to complete.</span>
<span class="ident">threads</span>
    .<span class="ident">into_iter</span>()
    .<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">t</span><span class="op">|</span> <span class="ident">t</span>.<span class="ident">join</span>().<span class="ident">expect</span>(<span class="string">&quot;Thread failed&quot;</span>));</code></pre></div>
<p><strong>Result</strong></p>
<ul>
<li>The <code>init</code> closure was called exactly once by thread 1.</li>
<li>Other threads were blocked until thread 1 inserted the value.</li>
</ul>
<div class="example-wrap"><pre class="language-console"><code>Thread 1 started.
Thread 0 started.
Thread 3 started.
Thread 2 started.
Thread 1 inserting a value.
Thread 2 got the value. (len: 10485760)
Thread 1 got the value. (len: 10485760)
Thread 0 got the value. (len: 10485760)
Thread 3 got the value. (len: 10485760)</code></pre></div><h5 id="panics"><a href="#panics">Panics</a></h5>
<p>This method panics when the <code>init</code> closure has been panicked. When it
happens, only the caller whose <code>init</code> closure panicked will get the panic
(e.g. only thread 1 in the above sample). If there are other calls in
progress (e.g. thread 0, 2 and 3 above), this method will restart and resolve
one of the remaining <code>init</code> closure.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_with_if" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#1024-1033">source</a></span><a href="#method.get_with_if" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_with_if" class="fnname">get_with_if</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;key: K, <br>&nbsp;&nbsp;&nbsp;&nbsp;init: impl <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; V, <br>&nbsp;&nbsp;&nbsp;&nbsp;replace_if: impl <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;</a>V) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.bool.html">bool</a><br>) -&gt; V</h4></section></summary><div class="docblock"><p>Works like <a href="#method.get_with"><code>get_with</code></a>, but takes an additional
<code>replace_if</code> closure.</p>
<p>This method will evaluate the <code>init</code> closure and insert the output to the
cache when:</p>
<ul>
<li>The key does not exist.</li>
<li>Or, <code>replace_if</code> closure returns <code>true</code>.</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_get_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#1147-1155">source</a></span><a href="#method.try_get_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.try_get_with" class="fnname">try_get_with</a>&lt;F, E&gt;(&amp;self, key: K, init: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.61.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;V, <a class="struct" href="https://doc.rust-lang.org/1.61.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;E&gt;&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/1.61.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;V, E&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;E: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h4></section></summary><div class="docblock"><p>Try to ensure the value of the key exists by inserting an <code>Ok</code> result of the
init closure if not exist, and returns a <em>clone</em> of the value or the <code>Err</code>
returned by the closure.</p>
<p>This method prevents to evaluate the init closure multiple times on the same
key even if the method is concurrently called by many threads; only one of
the calls evaluates its closure (as long as these closures return the same
error type), and other calls wait for that closure to complete.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">path::Path</span>, <span class="ident">time::Duration</span>, <span class="ident">thread</span>};

<span class="doccomment">/// This function tries to get the file size in bytes.</span>
<span class="kw">fn</span> <span class="ident">get_file_size</span>(<span class="ident">thread_id</span>: <span class="ident">u8</span>, <span class="ident">path</span>: <span class="kw">impl</span> <span class="ident">AsRef</span><span class="op">&lt;</span><span class="ident">Path</span><span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">u64</span>, <span class="ident">std::io::Error</span><span class="op">&gt;</span> {
    <span class="macro">println!</span>(<span class="string">&quot;get_file_size() called by thread {}.&quot;</span>, <span class="ident">thread_id</span>);
    <span class="prelude-val">Ok</span>(<span class="ident">std::fs::metadata</span>(<span class="ident">path</span>)<span class="question-mark">?</span>.<span class="ident">len</span>())
}

<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::new</span>(<span class="number">100</span>);

<span class="comment">// Spawn four threads.</span>
<span class="kw">let</span> <span class="ident">threads</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="number">0</span>..<span class="number">4_u8</span>)
    .<span class="ident">map</span>(<span class="op">|</span><span class="ident">thread_id</span><span class="op">|</span> {
        <span class="kw">let</span> <span class="ident">my_cache</span> <span class="op">=</span> <span class="ident">cache</span>.<span class="ident">clone</span>();
        <span class="ident">thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
            <span class="macro">println!</span>(<span class="string">&quot;Thread {} started.&quot;</span>, <span class="ident">thread_id</span>);

            <span class="comment">// Try to insert and get the value for key1. Although all four</span>
            <span class="comment">// threads will call `try_get_with` at the same time,</span>
            <span class="comment">// get_file_size() must be called only once.</span>
            <span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">my_cache</span>.<span class="ident">try_get_with</span>(
                <span class="string">&quot;key1&quot;</span>,
                <span class="op">|</span><span class="op">|</span> <span class="ident">get_file_size</span>(<span class="ident">thread_id</span>, <span class="string">&quot;./Cargo.toml&quot;</span>),
            );

            <span class="comment">// Ensure the value exists now.</span>
            <span class="macro">assert!</span>(<span class="ident">value</span>.<span class="ident">is_ok</span>());
            <span class="ident">thread::sleep</span>(<span class="ident">Duration::from_millis</span>(<span class="number">10</span>));
            <span class="macro">assert!</span>(<span class="ident">my_cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="string">&quot;key1&quot;</span>).<span class="ident">is_some</span>());

            <span class="macro">println!</span>(
                <span class="string">&quot;Thread {} got the value. (len: {})&quot;</span>,
                <span class="ident">thread_id</span>,
                <span class="ident">value</span>.<span class="ident">unwrap</span>()
            );
        })
    })
    .<span class="ident">collect</span>();

<span class="comment">// Wait all threads to complete.</span>
<span class="ident">threads</span>
    .<span class="ident">into_iter</span>()
    .<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">t</span><span class="op">|</span> <span class="ident">t</span>.<span class="ident">join</span>().<span class="ident">expect</span>(<span class="string">&quot;Thread failed&quot;</span>));</code></pre></div>
<p><strong>Result</strong></p>
<ul>
<li><code>get_file_size()</code> was called exactly once by thread 1.</li>
<li>Other threads were blocked until thread 1 inserted the value.</li>
</ul>
<div class="example-wrap"><pre class="language-console"><code>Thread 1 started.
Thread 2 started.
get_file_size() called by thread 1.
Thread 3 started.
Thread 0 started.
Thread 2 got the value. (len: 1466)
Thread 0 got the value. (len: 1466)
Thread 1 got the value. (len: 1466)
Thread 3 got the value. (len: 1466)</code></pre></div><h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>This method panics when the <code>init</code> closure has been panicked. When it
happens, only the caller whose <code>init</code> closure panicked will get the panic
(e.g. only thread 1 in the above sample). If there are other calls in
progress (e.g. thread 0, 2 and 3 above), this method will restart and resolve
one of the remaining <code>init</code> closure.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.insert" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#1189-1193">source</a></span><a href="#method.insert" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.insert" class="fnname">insert</a>(&amp;self, key: K, value: V)</h4></section></summary><div class="docblock"><p>Inserts a key-value pair into the cache.</p>
<p>If the cache has this key present, the value is updated.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.invalidate" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#1205-1212">source</a></span><a href="#method.invalidate" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.invalidate" class="fnname">invalidate</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;</a>Q) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.61.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;K&gt;: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;Q: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Discards any cached value for the key.</p>
<p>The key may be any borrowed form of the cache’s key type, but <code>Hash</code> and <code>Eq</code>
on the borrowed form <em>must</em> match those for the key type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.invalidate_all" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#1265-1267">source</a></span><a href="#method.invalidate_all" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.invalidate_all" class="fnname">invalidate_all</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Discards all cached values.</p>
<p>This method returns immediately and a background thread will evict all the
cached values inserted before the time when this method was called. It is
guaranteed that the <code>get</code> method must not return these invalidated values
even if they have not been evicted.</p>
<p>Like the <code>invalidate</code> method, this method does not clear the historic
popularity estimator of keys so that it retains the client activities of
trying to retrieve an item.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.invalidate_entries_if" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#1294-1299">source</a></span><a href="#method.invalidate_entries_if" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.invalidate_entries_if" class="fnname">invalidate_entries_if</a>&lt;F&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;predicate: F<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.61.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="type" href="type.PredicateId.html" title="type moka::sync::PredicateId">PredicateId</a>, <a class="enum" href="../enum.PredicateError.html" title="enum moka::PredicateError">PredicateError</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;</a>K, <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;</a>V) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.bool.html">bool</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h4></section></summary><div class="docblock"><p>Discards cached values that satisfy a predicate.</p>
<p><code>invalidate_entries_if</code> takes a closure that returns <code>true</code> or <code>false</code>. This
method returns immediately and a background thread will apply the closure to
each cached value inserted before the time when <code>invalidate_entries_if</code> was
called. If the closure returns <code>true</code> on a value, that value will be evicted
from the cache.</p>
<p>Also the <code>get</code> method will apply the closure to a value to determine if it
should have been invalidated. Therefore, it is guaranteed that the <code>get</code>
method must not return invalidated values.</p>
<p>Note that you must call
<a href="./struct.CacheBuilder.html#method.support_invalidation_closures"><code>CacheBuilder::support_invalidation_closures</code></a>
at the cache creation time as the cache needs to maintain additional internal
data structures to support this method. Otherwise, calling this method will
fail with a
<a href="../enum.PredicateError.html#variant.InvalidationClosuresDisabled"><code>PredicateError::InvalidationClosuresDisabled</code></a>.</p>
<p>Like the <code>invalidate</code> method, this method does not clear the historic
popularity estimator of keys so that it retains the client activities of
trying to retrieve an item.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#1358-1360">source</a></span><a href="#method.iter" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.iter" class="fnname">iter</a>(&amp;self) -&gt; <a class="struct" href="struct.Iter.html" title="struct moka::sync::Iter">Iter</a>&lt;'_, K, V&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.Iter.html" title="struct moka::sync::Iter">Iter</a>&lt;'i, K, V&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'i, K, V&gt; <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.Iter.html" title="struct moka::sync::Iter">Iter</a>&lt;'i, K, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.61.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.tuple.html">(</a><a class="struct" href="https://doc.rust-lang.org/1.61.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;K&gt;, V<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.tuple.html">)</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Creates an iterator visiting all key-value pairs in arbitrary order. The
iterator element type is <code>(Arc&lt;K&gt;, V)</code>, where <code>V</code> is a clone of a stored
value.</p>
<p>Iterators do not block concurrent reads and writes on the cache. An entry can
be inserted to, invalidated or evicted from a cache while iterators are alive
on the same cache.</p>
<p>Unlike the <code>get</code> method, visiting entries via an iterator do not update the
historic popularity estimator or reset idle timers for keys.</p>
<h5 id="guarantees"><a href="#guarantees">Guarantees</a></h5>
<p>In order to allow concurrent access to the cache, iterator’s <code>next</code> method
does <em>not</em> guarantee the following:</p>
<ul>
<li>It does not guarantee to return a key-value pair (an entry) if its key has
been inserted to the cache <em>after</em> the iterator was created.
<ul>
<li>Such an entry may or may not be returned depending on key’s hash and
timing.</li>
</ul>
</li>
</ul>
<p>and the <code>next</code> method guarantees the followings:</p>
<ul>
<li>It guarantees not to return the same entry more than once.</li>
<li>It guarantees not to return an entry if it has been removed from the cache
after the iterator was created.
<ul>
<li>Note: An entry can be removed by following reasons:
<ul>
<li>Manually invalidated.</li>
<li>Expired (e.g. time-to-live).</li>
<li>Evicted as the cache capacity exceeded.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;

<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::new</span>(<span class="number">100</span>);
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="string">&quot;Julia&quot;</span>, <span class="number">14</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">cache</span>.<span class="ident">iter</span>();
<span class="kw">let</span> (<span class="ident">k</span>, <span class="ident">v</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(); <span class="comment">// (Arc&lt;K&gt;, V)</span>
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span><span class="ident">k</span>, <span class="string">&quot;Julia&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, <span class="number">14</span>);

<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Clone" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#702-713">source</a></span><a href="#impl-Clone" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#707-712">source</a></span><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.61.0/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class="docblock"><p>Makes a clone of this shared cache.</p>
<p>This operation is cheap as it only creates thread-safe reference counted
pointers to the shared internal data structures.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/clone.rs.html#134-136">source</a></span><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.61.0/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.61.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-ConcurrentCacheExt%3CK%2C%20V%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#1378-1387">source</a></span><a href="#impl-ConcurrentCacheExt%3CK%2C%20V%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="trait.ConcurrentCacheExt.html" title="trait moka::sync::ConcurrentCacheExt">ConcurrentCacheExt</a>&lt;K, V&gt; for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.sync" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#1384-1386">source</a></span><a href="#method.sync" class="anchor"></a><h4 class="code-header">fn <a href="trait.ConcurrentCacheExt.html#tymethod.sync" class="fnname">sync</a>(&amp;self)</h4></section></summary><div class='docblock'><p>Performs any pending maintenance operations needed by the cache.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#715-731">source</a></span><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#722-730">source</a></span><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.61.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.61.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.61.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.61.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IntoIterator" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#1363-1376">source</a></span><a href="#impl-IntoIterator" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Item" class="type trait-impl has-srclink"><a href="#associatedtype.Item" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.61.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.tuple.html">(</a><a class="struct" href="https://doc.rust-lang.org/1.61.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;K&gt;, V<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.tuple.html">)</a></h4></section></summary><div class='docblock'><p>The type of the elements being iterated over.</p>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.IntoIter" class="type trait-impl has-srclink"><a href="#associatedtype.IntoIter" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.61.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="struct.Iter.html" title="struct moka::sync::Iter">Iter</a>&lt;'a, K, V&gt;</h4></section></summary><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_iter" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#1373-1375">source</a></span><a href="#method.into_iter" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.61.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.61.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'><p>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.61.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></p>
</div></details></div></details><section id="impl-Send" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#685-691">source</a></span><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></h3></section><section id="impl-Sync" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#693-699">source</a></span><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,&nbsp;</span></h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe" class="impl has-srclink"><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&nbsp;=&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.61.0/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/1.61.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></section><section id="impl-Unpin" class="impl has-srclink"><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></section><section id="impl-UnwindSafe" class="impl has-srclink"><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&nbsp;=&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.61.0/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/1.61.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/any.rs.html#132-136">source</a></span><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/any.rs.html#133">source</a></span><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.61.0/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.61.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.61.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/borrow.rs.html#209-214">source</a></span><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.61.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.61.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/borrow.rs.html#218-222">source</a></span><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.61.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.61.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.61.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/convert/mod.rs.html#557-562">source</a></span><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/convert/mod.rs.html#559">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.61.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/convert/mod.rs.html#541-552">source</a></span><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/convert/mod.rs.html#549">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.61.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.61.0/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToOwned" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/borrow.rs.html#84-96">source</a></span><a href="#impl-ToOwned" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.61.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Owned" class="type trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.61.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/borrow.rs.html#89">source</a></span><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.61.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.61.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/borrow.rs.html#93">source</a></span><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.61.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;mut </a>T)</h4></section></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.61.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/convert/mod.rs.html#598-607">source</a></span><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.61.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.61.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/convert/mod.rs.html#604">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.61.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.61.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.61.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/convert/mod.rs.html#583-592">source</a></span><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.61.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.61.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/convert/mod.rs.html#589">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.61.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.61.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.61.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.61.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="moka" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.61.0 (fe5b13d68 2022-05-18)" ></div>
</body></html>