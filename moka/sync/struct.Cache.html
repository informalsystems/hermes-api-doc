<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A thread-safe concurrent synchronous in-memory cache."><meta name="keywords" content="rust, rustlang, rust-lang, Cache"><title>Cache in moka::sync - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../moka/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../moka/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Cache</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.builder">builder</a></li><li><a href="#method.contains_key">contains_key</a></li><li><a href="#method.entry_count">entry_count</a></li><li><a href="#method.get">get</a></li><li><a href="#method.get_or_insert_with">get_or_insert_with</a></li><li><a href="#method.get_or_try_insert_with">get_or_try_insert_with</a></li><li><a href="#method.get_with">get_with</a></li><li><a href="#method.get_with_if">get_with_if</a></li><li><a href="#method.insert">insert</a></li><li><a href="#method.invalidate">invalidate</a></li><li><a href="#method.invalidate_all">invalidate_all</a></li><li><a href="#method.invalidate_entries_if">invalidate_entries_if</a></li><li><a href="#method.iter">iter</a></li><li><a href="#method.new">new</a></li><li><a href="#method.policy">policy</a></li><li><a href="#method.try_get_with">try_get_with</a></li><li><a href="#method.weighted_size">weighted_size</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-Clone">Clone</a></li><li><a href="#impl-ConcurrentCacheExt%3CK%2C%20V%3E">ConcurrentCacheExt&lt;K, V&gt;</a></li><li><a href="#impl-Debug">Debug</a></li><li><a href="#impl-IntoIterator">IntoIterator</a></li><li><a href="#impl-Send">Send</a></li><li><a href="#impl-Sync">Sync</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe">!UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In moka::sync</a></h2><div id="sidebar-vars" data-name="Cache" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../moka/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Struct <a href="../index.html">moka</a>::<wbr><a href="index.html">sync</a>::<wbr><a class="struct" href="#">Cache</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/moka/sync/cache.rs.html#230-233">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code>pub struct Cache&lt;K, V, S&nbsp;=&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.60.0/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt; { /* private fields */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A thread-safe concurrent synchronous in-memory cache.</p>
<p><code>Cache</code> supports full concurrency of retrievals and a high expected concurrency
for updates.</p>
<p><code>Cache</code> utilizes a lock-free concurrent hash table as the central key-value
storage. <code>Cache</code> performs a best-effort bounding of the map using an entry
replacement algorithm to determine which entries to evict when the capacity is
exceeded.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<p>Cache entries are manually added using <a href="#method.insert"><code>insert</code></a> or
<a href="#method.get_with"><code>get_with</code></a> methods, and are stored in
the cache until either evicted or manually invalidated.</p>
<p>Here’s an example of reading and updating a cache by using multiple threads:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;

<span class="kw">use</span> <span class="ident">std::thread</span>;

<span class="kw">fn</span> <span class="ident">value</span>(<span class="ident">n</span>: <span class="ident">usize</span>) -&gt; <span class="ident">String</span> {
    <span class="macro">format!</span>(<span class="string">&quot;value {}&quot;</span>, <span class="ident">n</span>)
}

<span class="kw">const</span> <span class="ident">NUM_THREADS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">16</span>;
<span class="kw">const</span> <span class="ident">NUM_KEYS_PER_THREAD</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">64</span>;

<span class="comment">// Create a cache that can store up to 10,000 entries.</span>
<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::new</span>(<span class="number">10_000</span>);

<span class="comment">// Spawn threads and read and update the cache simultaneously.</span>
<span class="kw">let</span> <span class="ident">threads</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="number">0</span>..<span class="ident">NUM_THREADS</span>)
    .<span class="ident">map</span>(<span class="op">|</span><span class="ident">i</span><span class="op">|</span> {
        <span class="comment">// To share the same cache across the threads, clone it.</span>
        <span class="comment">// This is a cheap operation.</span>
        <span class="kw">let</span> <span class="ident">my_cache</span> <span class="op">=</span> <span class="ident">cache</span>.<span class="ident">clone</span>();
        <span class="kw">let</span> <span class="ident">start</span> <span class="op">=</span> <span class="ident">i</span> <span class="op">*</span> <span class="ident">NUM_KEYS_PER_THREAD</span>;
        <span class="kw">let</span> <span class="ident">end</span> <span class="op">=</span> (<span class="ident">i</span> <span class="op">+</span> <span class="number">1</span>) <span class="op">*</span> <span class="ident">NUM_KEYS_PER_THREAD</span>;

        <span class="ident">thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
            <span class="comment">// Insert 64 entries. (NUM_KEYS_PER_THREAD = 64)</span>
            <span class="kw">for</span> <span class="ident">key</span> <span class="kw">in</span> <span class="ident">start</span>..<span class="ident">end</span> {
                <span class="ident">my_cache</span>.<span class="ident">insert</span>(<span class="ident">key</span>, <span class="ident">value</span>(<span class="ident">key</span>));
                <span class="comment">// get() returns Option&lt;String&gt;, a clone of the stored value.</span>
                <span class="macro">assert_eq!</span>(<span class="ident">my_cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>), <span class="prelude-val">Some</span>(<span class="ident">value</span>(<span class="ident">key</span>)));
            }

            <span class="comment">// Invalidate every 4 element of the inserted entries.</span>
            <span class="kw">for</span> <span class="ident">key</span> <span class="kw">in</span> (<span class="ident">start</span>..<span class="ident">end</span>).<span class="ident">step_by</span>(<span class="number">4</span>) {
                <span class="ident">my_cache</span>.<span class="ident">invalidate</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>);
            }
        })
    })
    .<span class="ident">collect</span>();

<span class="comment">// Wait for all threads to complete.</span>
<span class="ident">threads</span>.<span class="ident">into_iter</span>().<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">t</span><span class="op">|</span> <span class="ident">t</span>.<span class="ident">join</span>().<span class="ident">expect</span>(<span class="string">&quot;Failed&quot;</span>));

<span class="comment">// Verify the result.</span>
<span class="kw">for</span> <span class="ident">key</span> <span class="kw">in</span> <span class="number">0</span>..(<span class="ident">NUM_THREADS</span> <span class="op">*</span> <span class="ident">NUM_KEYS_PER_THREAD</span>) {
    <span class="kw">if</span> <span class="ident">key</span> <span class="op">%</span> <span class="number">4</span> <span class="op">==</span> <span class="number">0</span> {
        <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>), <span class="prelude-val">None</span>);
    } <span class="kw">else</span> {
        <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>), <span class="prelude-val">Some</span>(<span class="ident">value</span>(<span class="ident">key</span>)));
    }
}</code></pre></div>
<p>If you want to atomically initialize and insert a value when the key is not
present, you might want to check other insertion methods
<a href="#method.get_with"><code>get_with</code></a> and
<a href="#method.try_get_with"><code>try_get_with</code></a>.</p>
<h2 id="avoiding-to-clone-the-value-at-get"><a href="#avoiding-to-clone-the-value-at-get">Avoiding to clone the value at <code>get</code></a></h2>
<p>The return type of <code>get</code> method is <code>Option&lt;V&gt;</code> instead of <code>Option&lt;&amp;V&gt;</code>. Every
time <code>get</code> is called for an existing key, it creates a clone of the stored value
<code>V</code> and returns it. This is because the <code>Cache</code> allows concurrent updates from
threads so a value stored in the cache can be dropped or replaced at any time by
any other thread. <code>get</code> cannot return a reference <code>&amp;V</code> as it is impossible to
guarantee the value outlives the reference.</p>
<p>If you want to store values that will be expensive to clone, wrap them by
<code>std::sync::Arc</code> before storing in a cache. <a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code>Arc</code></a> is a
thread-safe reference-counted pointer and its <code>clone()</code> method is cheap.</p>
<h2 id="size-based-eviction"><a href="#size-based-eviction">Size-based Eviction</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::convert::TryInto</span>;
<span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;

<span class="comment">// Evict based on the number of entries in the cache.</span>
<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::builder</span>()
    <span class="comment">// Up to 10,000 entries.</span>
    .<span class="ident">max_capacity</span>(<span class="number">10_000</span>)
    <span class="comment">// Create the cache.</span>
    .<span class="ident">build</span>();
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>.<span class="ident">to_string</span>());

<span class="comment">// Evict based on the byte length of strings in the cache.</span>
<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::builder</span>()
    <span class="comment">// A weigher closure takes &amp;K and &amp;V and returns a u32</span>
    <span class="comment">// representing the relative size of the entry.</span>
    .<span class="ident">weigher</span>(<span class="op">|</span><span class="ident">_key</span>, <span class="ident">value</span>: <span class="kw-2">&amp;</span><span class="ident">String</span><span class="op">|</span> -&gt; <span class="ident">u32</span> {
        <span class="ident">value</span>.<span class="ident">len</span>().<span class="ident">try_into</span>().<span class="ident">unwrap_or</span>(<span class="ident">u32::MAX</span>)
    })
    <span class="comment">// This cache will hold up to 32MiB of values.</span>
    .<span class="ident">max_capacity</span>(<span class="number">32</span> <span class="op">*</span> <span class="number">1024</span> <span class="op">*</span> <span class="number">1024</span>)
    .<span class="ident">build</span>();
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>.<span class="ident">to_string</span>());</code></pre></div>
<p>If your cache should not grow beyond a certain size, use the <code>max_capacity</code>
method of the <a href="./struct.CacheBuilder.html"><code>CacheBuilder</code></a> to set the upper bound. The cache
will try to evict entries that have not been used recently or very often.</p>
<p>At the cache creation time, a weigher closure can be set by the <code>weigher</code> method
of the <code>CacheBuilder</code>. A weigher closure takes <code>&amp;K</code> and <code>&amp;V</code> as the arguments and
returns a <code>u32</code> representing the relative size of the entry:</p>
<ul>
<li>If the <code>weigher</code> is <em>not</em> set, the cache will treat each entry has the same
size of <code>1</code>. This means the cache will be bounded by the number of entries.</li>
<li>If the <code>weigher</code> is set, the cache will call the weigher to calculate the
weighted size (relative size) on an entry. This means the cache will be bounded
by the total weighted size of entries.</li>
</ul>
<p>Note that weighted sizes are not used when making eviction selections.</p>
<h2 id="time-based-expirations"><a href="#time-based-expirations">Time-based Expirations</a></h2>
<p><code>Cache</code> supports the following expiration policies:</p>
<ul>
<li><strong>Time to live</strong>: A cached entry will be expired after the specified duration
past from <code>insert</code>.</li>
<li><strong>Time to idle</strong>: A cached entry will be expired after the specified duration
past from <code>get</code> or <code>insert</code>.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;
<span class="kw">use</span> <span class="ident">std::time::Duration</span>;

<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::builder</span>()
    <span class="comment">// Time to live (TTL): 30 minutes</span>
    .<span class="ident">time_to_live</span>(<span class="ident">Duration::from_secs</span>(<span class="number">30</span> <span class="op">*</span> <span class="number">60</span>))
    <span class="comment">// Time to idle (TTI):  5 minutes</span>
    .<span class="ident">time_to_idle</span>(<span class="ident">Duration::from_secs</span>( <span class="number">5</span> <span class="op">*</span> <span class="number">60</span>))
    <span class="comment">// Create the cache.</span>
    .<span class="ident">build</span>();

<span class="comment">// This entry will expire after 5 minutes (TTI) if there is no get().</span>
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);

<span class="comment">// This get() will extend the entry life for another 5 minutes.</span>
<span class="ident">cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="number">0</span>);

<span class="comment">// Even though we keep calling get(), the entry will expire</span>
<span class="comment">// after 30 minutes (TTL) from the insert().</span></code></pre></div>
<h2 id="thread-safety"><a href="#thread-safety">Thread Safety</a></h2>
<p>All methods provided by the <code>Cache</code> are considered thread-safe, and can be safely
accessed by multiple concurrent threads.</p>
<ul>
<li><code>Cache&lt;K, V, S&gt;</code> requires trait bounds <code>Send</code>, <code>Sync</code> and <code>'static</code> for <code>K</code>
(key), <code>V</code> (value) and <code>S</code> (hasher state).</li>
<li><code>Cache&lt;K, V, S&gt;</code> will implement <code>Send</code> and <code>Sync</code>.</li>
</ul>
<h2 id="sharing-a-cache-across-threads"><a href="#sharing-a-cache-across-threads">Sharing a cache across threads</a></h2>
<p>To share a cache across threads, do one of the followings:</p>
<ul>
<li>Create a clone of the cache by calling its <code>clone</code> method and pass it to other
thread.</li>
<li>Wrap the cache by a <code>sync::OnceCell</code> or <code>sync::Lazy</code> from
<a href="https://crates.io/crates/once_cell">once_cell</a> create, and set it to a <code>static</code> variable.</li>
</ul>
<p>Cloning is a cheap operation for <code>Cache</code> as it only creates thread-safe
reference-counted pointers to the internal data structures.</p>
<h2 id="hashing-algorithm"><a href="#hashing-algorithm">Hashing Algorithm</a></h2>
<p>By default, <code>Cache</code> uses a hashing algorithm selected to provide resistance
against HashDoS attacks. It will be the same one used by
<code>std::collections::HashMap</code>, which is currently SipHash 1-3.</p>
<p>While SipHash’s performance is very competitive for medium sized keys, other
hashing algorithms will outperform it for small keys such as integers as well as
large keys such as long strings. However those algorithms will typically not
protect against attacks such as HashDoS.</p>
<p>The hashing algorithm can be replaced on a per-<code>Cache</code> basis using the
<a href="./struct.CacheBuilder.html#method.build_with_hasher"><code>build_with_hasher</code></a> method of the
<code>CacheBuilder</code>. Many alternative algorithms are available on crates.io, such
as the <a href="https://crates.io/crates/ahash">aHash</a> crate.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#285-342">source</a></span><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.policy" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#290-292">source</a></span><a href="#method.policy" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.policy" class="fnname">policy</a>(&amp;self) -&gt; <a class="struct" href="../struct.Policy.html" title="struct moka::Policy">Policy</a></h4></section></summary><div class="docblock"><p>Returns a read-only cache policy of this cache.</p>
<p>At this time, cache policy cannot be modified after cache creation.
A future version may support to modify it.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.entry_count" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#329-331">source</a></span><a href="#method.entry_count" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.entry_count" class="fnname">entry_count</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u64.html">u64</a></h4></section></summary><div class="docblock"><p>Returns an approximate number of entries in this cache.</p>
<p>The value returned is <em>an estimate</em>; the actual count may differ if there are
concurrent insertions or removals, or if some entries are pending removal due
to expiration. This inaccuracy can be mitigated by performing a <code>sync()</code>
first.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;

<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::new</span>(<span class="number">10</span>);
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="string">&#39;n&#39;</span>, <span class="string">&quot;Netherland Dwarf&quot;</span>);
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="string">&#39;l&#39;</span>, <span class="string">&quot;Lop Eared&quot;</span>);
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="string">&#39;d&#39;</span>, <span class="string">&quot;Dutch&quot;</span>);

<span class="comment">// Ensure an entry exists.</span>
<span class="macro">assert!</span>(<span class="ident">cache</span>.<span class="ident">contains_key</span>(<span class="kw-2">&amp;</span><span class="string">&#39;n&#39;</span>));

<span class="comment">// However, followings may print stale number zeros instead of threes.</span>
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">cache</span>.<span class="ident">entry_count</span>());   <span class="comment">// -&gt; 0</span>
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">cache</span>.<span class="ident">weighted_size</span>()); <span class="comment">// -&gt; 0</span>

<span class="comment">// To mitigate the inaccuracy, bring `ConcurrentCacheExt` trait to</span>
<span class="comment">// the scope so we can use `sync` method.</span>
<span class="kw">use</span> <span class="ident">moka::sync::ConcurrentCacheExt</span>;
<span class="comment">// Call `sync` to run pending internal tasks.</span>
<span class="ident">cache</span>.<span class="ident">sync</span>();

<span class="comment">// Followings will print the actual numbers.</span>
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">cache</span>.<span class="ident">entry_count</span>());   <span class="comment">// -&gt; 3</span>
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">cache</span>.<span class="ident">weighted_size</span>()); <span class="comment">// -&gt; 3</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.weighted_size" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#339-341">source</a></span><a href="#method.weighted_size" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.weighted_size" class="fnname">weighted_size</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u64.html">u64</a></h4></section></summary><div class="docblock"><p>Returns an approximate total weighted size of entries in this cache.</p>
<p>The value returned is <em>an estimate</em>; the actual size may differ if there are
concurrent insertions or removals, or if some entries are pending removal due
to expiration. This inaccuracy can be mitigated by performing a <code>sync()</code>
first. See <a href="#method.entry_count"><code>entry_count</code></a> for a sample code.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#344-375">source</a></span><a href="#impl-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V&gt; <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, <a class="struct" href="https://doc.rust-lang.org/1.60.0/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#355-366">source</a></span><a href="#method.new" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>(max_capacity: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u64.html">u64</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a new <code>Cache&lt;K, V&gt;</code> that will store up to the <code>max_capacity</code>.</p>
<p>To adjust various configuration knobs such as <code>initial_capacity</code> or
<code>time_to_live</code>, use the <a href="./struct.CacheBuilder.html"><code>CacheBuilder</code></a>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.builder" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#372-374">source</a></span><a href="#method.builder" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.builder" class="fnname">builder</a>() -&gt; <a class="struct" href="struct.CacheBuilder.html" title="struct moka::sync::CacheBuilder">CacheBuilder</a>&lt;K, V, <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, <a class="struct" href="https://doc.rust-lang.org/1.60.0/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a <a href="./struct.CacheBuilder.html"><code>CacheBuilder</code></a>, which can builds a <code>Cache</code> or
<code>SegmentedCache</code> with various configuration knobs.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-2" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#377-868">source</a></span><a href="#impl-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.contains_key" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#414-420">source</a></span><a href="#method.contains_key" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.contains_key" class="fnname">contains_key</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Q) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;K&gt;: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;Q: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the cache contains a value for the key.</p>
<p>Unlike the <code>get</code> method, this method is not considered a cache read operation,
so it does not update the historic popularity estimator or reset the idle
timer for the key.</p>
<p>The key may be any borrowed form of the cache’s key type, but <code>Hash</code> and <code>Eq</code>
on the borrowed form <em>must</em> match those for the key type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#440-446">source</a></span><a href="#method.get" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get" class="fnname">get</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Q) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;K&gt;: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;Q: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns a <em>clone</em> of the value corresponding to the key.</p>
<p>If you want to store values that will be expensive to clone, wrap them by
<code>std::sync::Arc</code> before storing in a cache. <a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code>Arc</code></a> is a
thread-safe reference-counted pointer and its <code>clone()</code> method is cheap.</p>
<p>The key may be any borrowed form of the cache’s key type, but <code>Hash</code> and <code>Eq</code>
on the borrowed form <em>must</em> match those for the key type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_or_insert_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#458-460">source</a></span><a href="#method.get_or_insert_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_or_insert_with" class="fnname">get_or_insert_with</a>(&amp;self, key: K, init: impl <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; V) -&gt; V</h4></section><div class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated since 0.8.0: <p>Replaced with <code>get_with</code></p>
</div></div></summary><div class="docblock"><p>Deprecated, replaced with <a href="#method.get_with"><code>get_with</code></a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_or_try_insert_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#464-470">source</a></span><a href="#method.get_or_try_insert_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_or_try_insert_with" class="fnname">get_or_try_insert_with</a>&lt;F, E&gt;(&amp;self, key: K, init: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;V, <a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;E&gt;&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;V, E&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;E: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h4></section><div class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated since 0.8.0: <p>Replaced with <code>try_get_with</code></p>
</div></div></summary><div class="docblock"><p>Deprecated, replaced with <a href="#method.try_get_with"><code>try_get_with</code></a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#545-550">source</a></span><a href="#method.get_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_with" class="fnname">get_with</a>(&amp;self, key: K, init: impl <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; V) -&gt; V</h4></section></summary><div class="docblock"><p>Ensures the value of the key exists by inserting the output of the <code>init</code>
closure if not exist, and returns a <em>clone</em> of the value.</p>
<p>This method prevents to evaluate the <code>init</code> closure multiple times on the
same key even if the method is concurrently called by many threads; only one
of the calls evaluates its closure, and other calls wait for that closure to
complete.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">sync::Arc</span>, <span class="ident">thread</span>, <span class="ident">time::Duration</span>};

<span class="kw">const</span> <span class="ident">TEN_MIB</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">10</span> <span class="op">*</span> <span class="number">1024</span> <span class="op">*</span> <span class="number">1024</span>; <span class="comment">// 10MiB</span>
<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::new</span>(<span class="number">100</span>);

<span class="comment">// Spawn four threads.</span>
<span class="kw">let</span> <span class="ident">threads</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="number">0</span>..<span class="number">4_u8</span>)
    .<span class="ident">map</span>(<span class="op">|</span><span class="ident">task_id</span><span class="op">|</span> {
        <span class="kw">let</span> <span class="ident">my_cache</span> <span class="op">=</span> <span class="ident">cache</span>.<span class="ident">clone</span>();
        <span class="ident">thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
            <span class="macro">println!</span>(<span class="string">&quot;Thread {} started.&quot;</span>, <span class="ident">task_id</span>);

            <span class="comment">// Try to insert and get the value for key1. Although all four</span>
            <span class="comment">// threads will call `get_with` at the same time, the `init` closure</span>
            <span class="comment">// must be evaluated only once.</span>
            <span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">my_cache</span>.<span class="ident">get_with</span>(<span class="string">&quot;key1&quot;</span>, <span class="op">|</span><span class="op">|</span> {
                <span class="macro">println!</span>(<span class="string">&quot;Thread {} inserting a value.&quot;</span>, <span class="ident">task_id</span>);
                <span class="ident">Arc::new</span>(<span class="macro">vec!</span>[<span class="number">0u8</span>; <span class="ident">TEN_MIB</span>])
            });

            <span class="comment">// Ensure the value exists now.</span>
            <span class="macro">assert_eq!</span>(<span class="ident">value</span>.<span class="ident">len</span>(), <span class="ident">TEN_MIB</span>);
            <span class="ident">thread::sleep</span>(<span class="ident">Duration::from_millis</span>(<span class="number">10</span>));
            <span class="macro">assert!</span>(<span class="ident">my_cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="string">&quot;key1&quot;</span>).<span class="ident">is_some</span>());

            <span class="macro">println!</span>(<span class="string">&quot;Thread {} got the value. (len: {})&quot;</span>, <span class="ident">task_id</span>, <span class="ident">value</span>.<span class="ident">len</span>());
        })
    })
    .<span class="ident">collect</span>();

<span class="comment">// Wait all threads to complete.</span>
<span class="ident">threads</span>
    .<span class="ident">into_iter</span>()
    .<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">t</span><span class="op">|</span> <span class="ident">t</span>.<span class="ident">join</span>().<span class="ident">expect</span>(<span class="string">&quot;Thread failed&quot;</span>));</code></pre></div>
<p><strong>Result</strong></p>
<ul>
<li>The <code>init</code> closure was called exactly once by thread 1.</li>
<li>Other threads were blocked until thread 1 inserted the value.</li>
</ul>
<div class="example-wrap"><pre class="language-console"><code>Thread 1 started.
Thread 0 started.
Thread 3 started.
Thread 2 started.
Thread 1 inserting a value.
Thread 2 got the value. (len: 10485760)
Thread 1 got the value. (len: 10485760)
Thread 0 got the value. (len: 10485760)
Thread 3 got the value. (len: 10485760)</code></pre></div><h5 id="panics"><a href="#panics">Panics</a></h5>
<p>This method panics when the <code>init</code> closure has been panicked. When it
happens, only the caller whose <code>init</code> closure panicked will get the panic
(e.g. only thread 1 in the above sample). If there are other calls in
progress (e.g. thread 0, 2 and 3 above), this method will restart and resolve
one of the remaining <code>init</code> closure.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_with_if" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#560-569">source</a></span><a href="#method.get_with_if" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_with_if" class="fnname">get_with_if</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;key: K, <br>&nbsp;&nbsp;&nbsp;&nbsp;init: impl <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; V, <br>&nbsp;&nbsp;&nbsp;&nbsp;replace_if: impl <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>V) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a><br>) -&gt; V</h4></section></summary><div class="docblock"><p>Works like <a href="#method.get_with"><code>get_with</code></a>, but takes an additional
<code>replace_if</code> closure.</p>
<p>This method will evaluate the <code>init</code> closure and insert the output to the
cache when:</p>
<ul>
<li>The key does not exist.</li>
<li>Or, <code>replace_if</code> closure returns <code>true</code>.</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_get_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#683-691">source</a></span><a href="#method.try_get_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.try_get_with" class="fnname">try_get_with</a>&lt;F, E&gt;(&amp;self, key: K, init: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;V, <a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;E&gt;&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;V, E&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;E: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h4></section></summary><div class="docblock"><p>Try to ensure the value of the key exists by inserting an <code>Ok</code> result of the
init closure if not exist, and returns a <em>clone</em> of the value or the <code>Err</code>
returned by the closure.</p>
<p>This method prevents to evaluate the init closure multiple times on the same
key even if the method is concurrently called by many threads; only one of
the calls evaluates its closure (as long as these closures return the same
error type), and other calls wait for that closure to complete.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">path::Path</span>, <span class="ident">time::Duration</span>, <span class="ident">thread</span>};

<span class="doccomment">/// This function tries to get the file size in bytes.</span>
<span class="kw">fn</span> <span class="ident">get_file_size</span>(<span class="ident">thread_id</span>: <span class="ident">u8</span>, <span class="ident">path</span>: <span class="kw">impl</span> <span class="ident">AsRef</span><span class="op">&lt;</span><span class="ident">Path</span><span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">u64</span>, <span class="ident">std::io::Error</span><span class="op">&gt;</span> {
    <span class="macro">println!</span>(<span class="string">&quot;get_file_size() called by thread {}.&quot;</span>, <span class="ident">thread_id</span>);
    <span class="prelude-val">Ok</span>(<span class="ident">std::fs::metadata</span>(<span class="ident">path</span>)<span class="question-mark">?</span>.<span class="ident">len</span>())
}

<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::new</span>(<span class="number">100</span>);

<span class="comment">// Spawn four threads.</span>
<span class="kw">let</span> <span class="ident">threads</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> (<span class="number">0</span>..<span class="number">4_u8</span>)
    .<span class="ident">map</span>(<span class="op">|</span><span class="ident">thread_id</span><span class="op">|</span> {
        <span class="kw">let</span> <span class="ident">my_cache</span> <span class="op">=</span> <span class="ident">cache</span>.<span class="ident">clone</span>();
        <span class="ident">thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
            <span class="macro">println!</span>(<span class="string">&quot;Thread {} started.&quot;</span>, <span class="ident">thread_id</span>);

            <span class="comment">// Try to insert and get the value for key1. Although all four</span>
            <span class="comment">// threads will call `try_get_with` at the same time,</span>
            <span class="comment">// get_file_size() must be called only once.</span>
            <span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">my_cache</span>.<span class="ident">try_get_with</span>(
                <span class="string">&quot;key1&quot;</span>,
                <span class="op">|</span><span class="op">|</span> <span class="ident">get_file_size</span>(<span class="ident">thread_id</span>, <span class="string">&quot;./Cargo.toml&quot;</span>),
            );

            <span class="comment">// Ensure the value exists now.</span>
            <span class="macro">assert!</span>(<span class="ident">value</span>.<span class="ident">is_ok</span>());
            <span class="ident">thread::sleep</span>(<span class="ident">Duration::from_millis</span>(<span class="number">10</span>));
            <span class="macro">assert!</span>(<span class="ident">my_cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="string">&quot;key1&quot;</span>).<span class="ident">is_some</span>());

            <span class="macro">println!</span>(
                <span class="string">&quot;Thread {} got the value. (len: {})&quot;</span>,
                <span class="ident">thread_id</span>,
                <span class="ident">value</span>.<span class="ident">unwrap</span>()
            );
        })
    })
    .<span class="ident">collect</span>();

<span class="comment">// Wait all threads to complete.</span>
<span class="ident">threads</span>
    .<span class="ident">into_iter</span>()
    .<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">t</span><span class="op">|</span> <span class="ident">t</span>.<span class="ident">join</span>().<span class="ident">expect</span>(<span class="string">&quot;Thread failed&quot;</span>));</code></pre></div>
<p><strong>Result</strong></p>
<ul>
<li><code>get_file_size()</code> was called exactly once by thread 1.</li>
<li>Other threads were blocked until thread 1 inserted the value.</li>
</ul>
<div class="example-wrap"><pre class="language-console"><code>Thread 1 started.
Thread 2 started.
get_file_size() called by thread 1.
Thread 3 started.
Thread 0 started.
Thread 2 got the value. (len: 1466)
Thread 0 got the value. (len: 1466)
Thread 1 got the value. (len: 1466)
Thread 3 got the value. (len: 1466)</code></pre></div><h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>This method panics when the <code>init</code> closure has been panicked. When it
happens, only the caller whose <code>init</code> closure panicked will get the panic
(e.g. only thread 1 in the above sample). If there are other calls in
progress (e.g. thread 0, 2 and 3 above), this method will restart and resolve
one of the remaining <code>init</code> closure.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.insert" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#725-729">source</a></span><a href="#method.insert" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.insert" class="fnname">insert</a>(&amp;self, key: K, value: V)</h4></section></summary><div class="docblock"><p>Inserts a key-value pair into the cache.</p>
<p>If the cache has this key present, the value is updated.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.invalidate" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#741-748">source</a></span><a href="#method.invalidate" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.invalidate" class="fnname">invalidate</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Q) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;K&gt;: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;Q: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Discards any cached value for the key.</p>
<p>The key may be any borrowed form of the cache’s key type, but <code>Hash</code> and <code>Eq</code>
on the borrowed form <em>must</em> match those for the key type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.invalidate_all" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#772-774">source</a></span><a href="#method.invalidate_all" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.invalidate_all" class="fnname">invalidate_all</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Discards all cached values.</p>
<p>This method returns immediately and a background thread will evict all the
cached values inserted before the time when this method was called. It is
guaranteed that the <code>get</code> method must not return these invalidated values
even if they have not been evicted.</p>
<p>Like the <code>invalidate</code> method, this method does not clear the historic
popularity estimator of keys so that it retains the client activities of
trying to retrieve an item.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.invalidate_entries_if" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#801-806">source</a></span><a href="#method.invalidate_entries_if" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.invalidate_entries_if" class="fnname">invalidate_entries_if</a>&lt;F&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;predicate: F<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="type" href="type.PredicateId.html" title="type moka::sync::PredicateId">PredicateId</a>, <a class="enum" href="../enum.PredicateError.html" title="enum moka::PredicateError">PredicateError</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>K, <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>V) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h4></section></summary><div class="docblock"><p>Discards cached values that satisfy a predicate.</p>
<p><code>invalidate_entries_if</code> takes a closure that returns <code>true</code> or <code>false</code>. This
method returns immediately and a background thread will apply the closure to
each cached value inserted before the time when <code>invalidate_entries_if</code> was
called. If the closure returns <code>true</code> on a value, that value will be evicted
from the cache.</p>
<p>Also the <code>get</code> method will apply the closure to a value to determine if it
should have been invalidated. Therefore, it is guaranteed that the <code>get</code>
method must not return invalidated values.</p>
<p>Note that you must call
<a href="./struct.CacheBuilder.html#method.support_invalidation_closures"><code>CacheBuilder::support_invalidation_closures</code></a>
at the cache creation time as the cache needs to maintain additional internal
data structures to support this method. Otherwise, calling this method will
fail with a
<a href="../enum.PredicateError.html#variant.InvalidationClosuresDisabled"><code>PredicateError::InvalidationClosuresDisabled</code></a>.</p>
<p>Like the <code>invalidate</code> method, this method does not clear the historic
popularity estimator of keys so that it retains the client activities of
trying to retrieve an item.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#865-867">source</a></span><a href="#method.iter" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.iter" class="fnname">iter</a>(&amp;self) -&gt; <a class="struct" href="struct.Iter.html" title="struct moka::sync::Iter">Iter</a>&lt;'_, K, V&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.Iter.html" title="struct moka::sync::Iter">Iter</a>&lt;'i, K, V&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'i, K, V&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.Iter.html" title="struct moka::sync::Iter">Iter</a>&lt;'i, K, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">(</a><a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;K&gt;, V<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">)</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Creates an iterator visiting all key-value pairs in arbitrary order. The
iterator element type is <code>(Arc&lt;K&gt;, V)</code>, where <code>V</code> is a clone of a stored
value.</p>
<p>Iterators do not block concurrent reads and writes on the cache. An entry can
be inserted to, invalidated or evicted from a cache while iterators are alive
on the same cache.</p>
<p>Unlike the <code>get</code> method, visiting entries via an iterator do not update the
historic popularity estimator or reset idle timers for keys.</p>
<h5 id="guarantees"><a href="#guarantees">Guarantees</a></h5>
<p>In order to allow concurrent access to the cache, iterator’s <code>next</code> method
does <em>not</em> guarantee the following:</p>
<ul>
<li>It does not guarantee to return a key-value pair (an entry) if its key has
been inserted to the cache <em>after</em> the iterator was created.
<ul>
<li>Such an entry may or may not be returned depending on key’s hash and
timing.</li>
</ul>
</li>
</ul>
<p>and the <code>next</code> method guarantees the followings:</p>
<ul>
<li>It guarantees not to return the same entry more than once.</li>
<li>It guarantees not to return an entry if it has been removed from the cache
after the iterator was created.
<ul>
<li>Note: An entry can be removed by following reasons:
<ul>
<li>Manually invalidated.</li>
<li>Expired (e.g. time-to-live).</li>
<li>Evicted as the cache capacity exceeded.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">moka::sync::Cache</span>;

<span class="kw">let</span> <span class="ident">cache</span> <span class="op">=</span> <span class="ident">Cache::new</span>(<span class="number">100</span>);
<span class="ident">cache</span>.<span class="ident">insert</span>(<span class="string">&quot;Julia&quot;</span>, <span class="number">14</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">cache</span>.<span class="ident">iter</span>();
<span class="kw">let</span> (<span class="ident">k</span>, <span class="ident">v</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(); <span class="comment">// (Arc&lt;K&gt;, V)</span>
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span><span class="ident">k</span>, <span class="string">&quot;Julia&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, <span class="number">14</span>);

<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Clone" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#254-265">source</a></span><a href="#impl-Clone" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#259-264">source</a></span><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class="docblock"><p>Makes a clone of this shared cache.</p>
<p>This operation is cheap as it only creates thread-safe reference counted
pointers to the shared internal data structures.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/clone.rs.html#130">source</a></span><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-ConcurrentCacheExt%3CK%2C%20V%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#885-894">source</a></span><a href="#impl-ConcurrentCacheExt%3CK%2C%20V%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="trait.ConcurrentCacheExt.html" title="trait moka::sync::ConcurrentCacheExt">ConcurrentCacheExt</a>&lt;K, V&gt; for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.sync" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#891-893">source</a></span><a href="#method.sync" class="anchor"></a><h4 class="code-header">fn <a href="trait.ConcurrentCacheExt.html#tymethod.sync" class="fnname">sync</a>(&amp;self)</h4></section></summary><div class='docblock'><p>Performs any pending maintenance operations needed by the cache.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#267-283">source</a></span><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#274-282">source</a></span><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.60.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IntoIterator" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#870-883">source</a></span><a href="#impl-IntoIterator" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Item" class="type trait-impl has-srclink"><a href="#associatedtype.Item" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">(</a><a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;K&gt;, V<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">)</a></h4></section></summary><div class='docblock'><p>The type of the elements being iterated over.</p>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.IntoIter" class="type trait-impl has-srclink"><a href="#associatedtype.IntoIter" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="struct.Iter.html" title="struct moka::sync::Iter">Iter</a>&lt;'a, K, V&gt;</h4></section></summary><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_iter" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#880-882">source</a></span><a href="#method.into_iter" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'><p>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></p>
</div></details></div></details><section id="impl-Send" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#237-243">source</a></span><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></h3></section><section id="impl-Sync" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/moka/sync/cache.rs.html#245-251">source</a></span><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,&nbsp;</span></h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe" class="impl has-srclink"><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&nbsp;=&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.60.0/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></section><section id="impl-Unpin" class="impl has-srclink"><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></section><section id="impl-UnwindSafe" class="impl has-srclink"><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;K, V, S&nbsp;=&nbsp;<a class="struct" href="https://doc.rust-lang.org/1.60.0/std/collections/hash/map/struct.RandomState.html" title="struct std::collections::hash::map::RandomState">RandomState</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Any" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/any.rs.html#132-136">source</a></span><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/any.rs.html#133">source</a></span><a href="#method.type_id" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.60.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Borrow%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/borrow.rs.html#209-214">source</a></span><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/borrow.rs.html#218-222">source</a></span><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#553-558">source</a></span><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#555">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Into%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#537-548">source</a></span><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#545">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-ToOwned" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/alloc/borrow.rs.html#84-96">source</a></span><a href="#impl-ToOwned" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Owned" class="type trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/alloc/borrow.rs.html#89">source</a></span><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/alloc/borrow.rs.html#93">source</a></span><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;mut </a>T)</h4></section></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-TryFrom%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#594-603">source</a></span><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#600">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-TryInto%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#579-588">source</a></span><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#585">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="moka" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.60.0 (7737e0b5c 2022-04-04)" ></div>
</body></html>