searchState.loadedDescShard("bech32", 0, "Encoding and decoding of the Bech32 format.\nThe bech32 checksum algorithm, defined in [BIP-173]. […\nThe bech32m checksum algorithm, defined in [BIP-350]. […\nExtension trait for byte iterators which provides an …\nThe number of characters in the checksum.\nTrait defining a particular checksum.\nNo valid bech32 or bech32m checksum.\nDecode error.\nAn error while decoding an address.\nAn error while decoding an address from a reader.\nAn element in GF(32), the finite field containing elements …\nExtension trait for field element iterators.\nThe coefficients of the generator polynomial, except the …\nThe human-readable part (human readable prefix before the …\nAn unsigned integer type capable of holding a packed …\nThe “null checksum” used on bech32 strings for which …\nParsing failed.\nRead error.\nThe residue, modulo the generator polynomial, that a valid …\nAdapts the byte iterator to output GF32 field elements …\nDecodes a bech32 encoded string.\nEncodes <code>data</code> as a lowercase bech32 encoded string.\nEncodes <code>data</code> as a lowercase bech32 encoded string.\nEncodes <code>data</code> to a writer (<code>fmt::Write</code>) as a lowercase …\nEncodes <code>data</code> to a writer (<code>std::io::Write</code>) as a lowercase …\nEncodes <code>data</code> to a writer (<code>fmt::Write</code>) as a lowercase …\nEncodes <code>data</code> to a writer (<code>std::io::Write</code>) as a lowercase …\nEncodes <code>data</code> as an uppercase bech32 encoded string.\nEncodes <code>data</code> to a writer (<code>fmt::Write</code>) as a uppercase …\nEncodes <code>data</code> to a writer (<code>std::io::Write</code>) as a uppercase …\nAdapts the <code>Fe32</code> iterator to output bytes instead.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRe-exports the hrp types from <code>primitives::hrp</code> to make …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAll the primitive types and functionality used in encoding …\nSanity checks that the various constants of the trait are …\nAPI for encoding and decoding segwit addresses. Segregated …\nTries to create an <code>Fe32</code> type from a signed source number …\nTries to create an <code>Fe32</code> type from a signed source number …\nTries to create an <code>Fe32</code> type from a signed source number …\nTries to create an <code>Fe32</code> type from a signed source number …\nTries to create an <code>Fe32</code> type from a signed source number …\nTries to create an <code>Fe32</code> type from a signed source number …\nTries to create an <code>Fe32</code> type from a signed source number …\nTries to create an <code>Fe32</code> type from a signed source number …\nTries to create an <code>Fe32</code> type from a signed source number …\nTries to create an <code>Fe32</code> type from a signed source number …\nAdapts the Fe32 iterator to encode the field elements into …\nThe human-readable part used by the Bitcoin mainnet …\nThe human-readable part used when running a Bitcoin …\nThe human-readable part (human readable prefix before the …\nThe human-readable part used by the Bitcoin testnet …\nThe bech32 checksum algorithm, defined in [BIP-173]. […\nThe bech32m checksum algorithm, defined in [BIP-350]. […\nThe “null checksum” used on bech32 strings for which …\nDegree-2 BCH code checksum.\nDecoding of bech32 encoded strings as specified by BIP-173 …\nBech32 address encoding.\nGF32 - Galois Field over 32 elements.\nProvides an <code>Hrp</code> type that represents the human-readable …\nIterator Adaptors.\nSegregated Witness functionality - useful for enforcing …\nThe number of characters in the checksum.\nTrait defining a particular checksum.\nA checksum engine, which can be used to compute or verify …\nThe coefficients of the generator polynomial, except the …\nIterator that yields the field elements that are input …\nAn unsigned integer type capable of holding a packed …\nThe one constant, for which stdlib provides no existing …\nTrait describing an integer type which can be used as a “…\nA placeholder type used as part of the …\nThe residue, modulo the generator polynomial, that a valid …\nThe number of fe32s that can fit into the type; computed …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdds a single gf32 element to the checksum engine.\nFeeds <code>hrp</code> into the checksum engine.\nInputs the target residue of the checksum.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMultiply the polynomial by x, drop its highest coefficient …\nCreates an iterator that yields the field elements of <code>hrp</code> …\nConstructs a new checksum engine with no data input.\nReturns for the current checksum residue.\nSanity checks that the various constants of the trait are …\nExtracts the coefficient of the x^n from the packed …\nAn iterator over a parsed HRP string data as bytes.\nAn error with the characters of the input string.\nCharacter errors in a bech32 encoded string.\nAn HRP string that has been parsed and had the checksum …\nAn error while constructing a <code>CheckedHrpstring</code> type.\nInvalid checksum.\nInvalid checksum.\nErrors in the checksum of a bech32 encoded string.\nAn iterator over a parsed HRP string data as field …\nThe human-readable part is invalid.\nSome part of the string contains an invalid character.\nThe checksum does not match the rest of the data.\nThe checksum does not match the rest of the data.\nThe checksum is not a valid length.\nThe checksum is not a valid length.\nInvalid witness version (must be 0-16 inclusive).\nString does not contain the separator character.\nThe witness version byte is missing.\nThe whole string must be of one case.\nThe data payload is padded with non-zero bits.\nNo characters after the separator.\nInvalid padding on the witness data.\nError validating the padding bits on the witness data.\nError while parsing the encoded address string.\nAn HRP string that has been parsed, had the checksum …\nAn error while constructing a <code>SegwitHrpstring</code> type.\nThe data payload has too many bits of padding.\nError while parsing the encoded address string.\nAn HRP string that has been parsed but not yet had the …\nErrors when parsing a bech32 encoded string.\nInvalid witness length.\nReturns an iterator that yields the data part of the …\nReturns an iterator that yields the data part, excluding …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nValidates that data has a valid checksum for the <code>Ck</code> …\nReturns <code>true</code> if the HRP is “bc” or “tb”.\nReturns the human-readable part.\nReturns the human-readable part.\nReturns the human-readable part.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParses an bech32 encode string and constructs a …\nParses and validates an HRP string, without treating the …\nParses an HRP string, treating the first data character as …\nParses an HRP string, treating the first data character as …\nRemoves the checksum for the <code>Ck</code> algorithm and returns an …\nValidates that data has a valid checksum for the <code>Ck</code> …\nValidates that data has a valid checksum for the <code>Ck</code> …\nConverts this type to a <code>SegwitHrpstring</code> after validating …\nReturns the witness version.\nIterator adaptor which takes a stream of field elements, …\nThe <code>Encoder</code> builds iterators that can be used to encode …\nIterator adaptor for a checksummed iterator that inputs …\nIterator adaptor that just prepends a single character to …\nReturns an iterator that yields the bech32 encoded address …\nReturns an iterator that yields the field elements that go …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a <code>WitnessVersionIter</code>.\nAdapts the <code>Fe32Iter</code> iterator to yield characters …\nCreates a <code>Fe32Iter</code> which yields all the field elements …\nConstructs a new bech32 encoder.\nAdds <code>witness_version</code> to the encoder (as first byte of …\nNumeric value maps to bech32 character: 29 == “a”.\nNumeric value maps to bech32 character: 24 == “c”.\nNumeric value maps to bech32 character: 13 == “d”.\nNumeric value maps to bech32 character: 25 == “e”.\nA galois field related error.\nNumeric value maps to bech32 character: 9 == “f”.\nAn element in GF(32), the finite field containing elements …\nNumeric value maps to bech32 character: 8 == “g”.\nNumeric value maps to bech32 character: 23 == “h”.\nTried to interpret a byte as a GF32 element but its …\nTried to interpret a character as a GF32 element but it is …\nNumeric value maps to bech32 character: 18 == “j”.\nNumeric value maps to bech32 character: 22 == “k”.\nNumeric value maps to bech32 character: 31 == “l”.\nNumeric value maps to bech32 character: 27 == “m”.\nNumeric value maps to bech32 character: 19 == “n”.\nTried to interpret an integer as a GF32 element but it …\nNumeric value maps to bech32 character: 1 == “p”.\nNumeric value maps to bech32 character: 0 == “q”.\nNumeric value maps to bech32 character: 3 == “r”.\nNumeric value maps to bech32 character: 16 == “s”.\nNumeric value maps to bech32 character: 11 == “t”.\nNumeric value maps to bech32 character: 28 == “u”.\nNumeric value maps to bech32 character: 12 == “v”.\nNumeric value maps to bech32 character: 14 == “w”.\nNumeric value maps to bech32 character: 6 == “x”.\nNumeric value maps to bech32 character: 4 == “y”.\nNumeric value maps to bech32 character: 2 == “z”.\nNumeric value maps to bech32 character: 15 == “0”.\nNumeric value maps to bech32 character: 10 == “2”.\nNumeric value maps to bech32 character: 17 == “3”.\nNumeric value maps to bech32 character: 21 == “4”.\nNumeric value maps to bech32 character: 20 == “5”.\nNumeric value maps to bech32 character: 26 == “6”.\nNumeric value maps to bech32 character: 30 == “7”.\nNumeric value maps to bech32 character: 7 == “8”.\nNumeric value maps to bech32 character: 5 == “9”.\nReturns the argument unchanged.\nCreates a field element from a single bech32 character.\nCalls <code>U::from(self)</code>.\nIterator over all field elements, in alphabetical order.\nConverts the field element to a lowercase bech32 character.\nConverts the field element to a 5-bit u8, with bits …\nThe human-readable part used by the Bitcoin mainnet …\nThe human-readable part used when running a Bitcoin …\nIterator over bytes (ASCII values) of the human-readable …\nIterator over ASCII characters of the human-readable part.\nThe human-readable part is empty.\nErrors encountered while checking the human-readable part …\nThe human-readable part (human readable prefix before the …\nByte value not within acceptable US-ASCII range.\nIterator over lowercase bytes (ASCII characters) of the …\nIterator over lowercase ASCII characters of the …\nThe human-readable part cannot mix upper and lower case.\nFound a non-ASCII character.\nThe human-readable part used by the Bitcoin testnet …\nThe human-readable part is too long.\nCreates a byte iterator over the ASCII byte values (ASCII …\nCreates a character iterator over the ASCII characters of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if this hrpstring is valid on the Bitcoin …\nReturns <code>true</code> if this hrpstring is valid on the Bitcoin …\nReturns <code>true</code> if this hrpstring is valid on the Bitcoin …\nReturns <code>true</code> if this hrpstring is valid on the Bitcoin …\nReturns <code>true</code> if this <code>Hrp</code> is valid according to the bips.\nReturns the length (number of characters) of the …\nCreates a lowercase iterator over the byte values (ASCII …\nCreates a lowercase character iterator over the ASCII …\nParses the human-readable part checking it is valid as …\nParses the human-readable part (see <code>Hrp::parse</code> for full …\nReturns this human-readable part as a lowercase string.\nExtension trait for byte iterators which provides an …\nIterator adaptor that converts bytes to GF32 elements.\nIterator adaptor for field-element-yielding iterator, …\nExtension trait for field element iterators.\nIterator adaptor that converts GF32 elements to bytes.\nAdapts the byte iterator to output GF32 field elements …\nAdapts the <code>Fe32</code> iterator to output bytes instead.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new checksummed iterator which adapts a data …\nCreates a new checksummed iterator which adapts a data …\nAdapts the Fe32 iterator to encode the field elements into …\nThe segwit v0 witness is not 20 or 32 bytes long.\nField element does not represent a valid witness version.\nThe witness data is too long.\nThe witness data is too short.\nThe field element representing segwit version 0.\nThe field element representing segwit version 1 (taproot).\nWitness program invalid because of incorrect length.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if <code>length</code> represents a valid witness program …\nReturns true if given field element represents a valid …\nValidates the segwit witness program <code>length</code> rules for …\nChecks that the given field element represents a valid …\nDecode error.\nAn error while decoding a segwit address.\nAn error while decoding a segwit address from a reader.\nAn error while constructing a <code>SegwitHrpstring</code> type.\nRead error.\nThe field element representing segwit version 0.\nThe field element representing segwit version 1 (taproot).\nInvalid witness length.\nInvalid witness version (must be 0-16 inclusive).\nWriting to formatter failed.\nDecodes a segwit address.\nEncodes a segwit address.\nEncodes a segwit address to a writer (<code>fmt::Write</code>) using …\nEncodes a segwit address to a writer (<code>std::io::Write</code>) …\nEncodes a segwit address to a writer (<code>fmt::Write</code>) using …\nEncodes a segwit address to a writer (<code>std::io::Write</code>) …\nEncodes a segwit address to a writer (<code>fmt::Write</code>) using …\nEncodes a segwit address to a <code>std::io::Write</code> writer using …\nEncodes a segwit version 0 address.\nEncodes a segwit version 1 address.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")