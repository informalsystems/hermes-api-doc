searchState.loadedDescShard("subtle_encoding", 0, "Encoders and decoders for common data encodings (base64, …\nChecksum fdoes not match expected value\nData is not encoded correctly\nError type\nError performing I/O operation\nInput or output buffer is an incorrect length\nPadding missing/invalid\nTrailing whitespace detected\nBase64 encoding with (almost) data-independent constant …\nBech32 (BIP-173) checksummed Base32 data encoding …\nThe <code>Encoding</code> trait: common operations across all encoders\nReturns the argument unchanged.\nHex encoding/decoding with data-independent constant …\nIdentity <code>Encoding</code>: output is identical to input\nCalls <code>U::from(self)</code>.\nBase64 <code>Encoding</code> (traditional non-URL-safe RFC 4648 version)\nDecode the given data from Base64, returning a <code>Vec&lt;u8&gt;</code>\nEncode the given data as Base64, returning a <code>Vec&lt;u8&gt;</code>\nReturn a <code>Base64</code> encoder\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBech32 encoder/decoder\nBech32 default alphabet (lower case)\nBech32 default alphabet (upper case)\nDefault separator character\nDecode the given data from lower-case Bech32, returning a …\nDecode a bech32 string to a human-readable part (HRP) and …\nDecode the given data from upper-case Bech32, returning a …\nEncode the given data as lower-case Bech32, returning a …\nEncode a bech32 string from a human-readable part (hrp) …\nEncode the given data as upper-case Bech32, returning a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDecode lower case Bech32 strings\nCreate a <code>Bech32</code> encoder with the given separator character\nReturn the separator character currently in use\nDecode upper case Bech32 strings\nAll encoding types in this crate implement this trait\nMode to use for newly created files\nDecode the given buffer, returning a <code>Vec&lt;u8&gt;</code>\nRead a file at the given path, decoding the data it …\nDecode the data read from the given <code>io::Read</code> type with this\nDecode the given string-alike type with this <code>Encoding</code>, …\nDecode hexadecimal (upper or lower case) with branchless / …\nCalculate the length of the given data after decoding.\nEncode the given buffer, returning a <code>Vec&lt;u8&gt;</code>\nEncode <code>self</code> and write it to a file at the given path, …\nEncode the given slice into the destination buffer.\nEncode the given slice to a <code>String</code> with this <code>Encoding</code>.\nEncode the given slice with this <code>Encoding</code>, writing the …\nCalculate the length of the given data after encoding.\nHexadecimal <code>Encoding</code> (a.k.a. Base16)\nDecode the given data from lower-case hexadecimal, …\nDecode the given data from upper-case hexadecimal, …\nEncode the given data as lower-case hexadecimal, returning …\nEncode the given data as upper-case hexadecimal, returning …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLower case hex: 0-9 a-f\nUpper case hex: 0-9 A-F\nConstant <code>Identity</code> encoding that can be used in lieu of …\n<code>Encoding</code> which does not transform data and returns the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")