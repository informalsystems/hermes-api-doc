<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Strongly typed pointers with reserved space for storing additional bit patterns within the same memory word."><meta name="keywords" content="rust, rustlang, rust-lang, tagptr"><title>tagptr - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c722f88035d2892e.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-4743e13df3dfe8c4.css"><link rel="stylesheet" disabled href="../static.files/dark-0e1b889528bd466b.css"><link rel="stylesheet" disabled href="../static.files/ayu-65289d5d067c7c66.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-bc1b32400f872ddb.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../tagptr/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../tagptr/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate tagptr</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.2.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">tagptr</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/tagptr/lib.rs.html#1-225">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Strongly typed pointers with reserved space for storing additional bit
patterns within the same memory word.</p>
<h2 id="motivation"><a href="#motivation">Motivation</a></h2>
<p>In low-level concurrent programming (synchronization primitives,
lock-free data structures, etc) it is often required to store additional
state information (tags) alongside pointers to objects in memory, since
most atomic CPU instructions operate on pointer-wide memory words.
The marked pointer types provided by this crate encapsulate the logic and
pointer arithmetic for composing (creating), decomposing and mutating
such pointers and tag values.</p>
<h2 id="tag-bits-and-type-alignment"><a href="#tag-bits-and-type-alignment">Tag Bits and Type Alignment</a></h2>
<p>The possible space for storing tag bits in a pointer is determined by the
alignment of the pointed-to type, as long as the pointer is well-aligned
(e.g., not packed).
For instance, pointers to types with an alignment of 2 (2^1) bytes (e.g.,
<code>u16</code>) never use the first of their lower bits (i.e., it is always zero),
pointers to types with an alignment of 8 (2^3) bytes such as <code>u64</code> never
use their 3 lowest bits and so on.
Great care must be taken at all times to avoid over- or underflows in the
usually highly restricted range of valid tags for common tag sizes when
doing arithmetic operations.
Any operations resulting in tag values outside of their valid range will
invariably corrupt the bits representing the pointer and hence invoke
undefined behavior when dereferencing these pointers.</p>
<p>Constructing a type such as <code>TagPtr&lt;u64, 4&gt;</code> is hence usually a user error,
since a pointer to a <code>u64</code> has only 3 unused bits.
The resulting type would consider the first actual bit of the pointer to be
part of its tag and return a potentially corrupted pointer in methods such
as <a href="struct.TagPtr.html#method.decompose" title="TagPtr::decompose"><code>decompose</code></a>.
The <a href="fn.has_sufficient_alignment.html" title="has_sufficient_alignment"><code>has_sufficient_alignment</code></a> and <a href="fn.assert_alignment.html" title="assert_alignment"><code>assert_alignment</code></a> functions can be
used to explicitly check for or assert this property.
There is, however, one exception where using an otherwise ill-formed tag
pointer type is valid:
After composing a well-formed tag pointer instance (e.g., <code>TagPtr&lt;u64, 3&gt;</code>)
it is valid to <a href="struct.TagPtr.html#method.cast" title="TagPtr::cast"><code>cast</code></a> it to a type with a smaller alignment
and the same number of tag bits such as <code>TagPtr&lt;(), 3&gt;</code> for the purpose of
type-erasure.</p>
<h2 id="example"><a href="#example">Example</a></h2>
<p>Storing a boolean status flag alongside the pointer to a mutable <code>u64</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">type </span>TagPtr = tagptr::TagPtr&lt;u64, <span class="number">3</span>&gt;;

<span class="kw">let </span><span class="kw-2">mut </span>val = <span class="number">0xCAFE</span>;
<span class="kw">let </span>is_ok = <span class="bool-val">true</span>;

<span class="kw">let </span>ptr = TagPtr::compose(<span class="kw-2">&amp;mut </span>val, is_ok <span class="kw">as </span>usize);
<span class="kw">let </span>(reference, tag) = <span class="kw">unsafe </span>{ ptr.decompose_mut() };
<span class="macro">assert_eq!</span>(reference, <span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span><span class="number">0xCAFE</span>));
<span class="macro">assert_eq!</span>(tag == <span class="number">1</span>, <span class="bool-val">true</span>);</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.AtomicTagPtr.html" title="tagptr::AtomicTagPtr struct">AtomicTagPtr</a></div><div class="item-right docblock-short">A raw pointer type which can be safely shared between threads and which can
use up to <code>N</code> of its lower bits to store additional information (the <em>tag</em>).</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Null.html" title="tagptr::Null struct">Null</a></div><div class="item-right docblock-short">A type representing a <code>null</code> pointer with potential tag bits.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TagNonNull.html" title="tagptr::TagNonNull struct">TagNonNull</a></div><div class="item-right docblock-short">A non-nullable tagged raw pointer type similar to <a href="https://doc.rust-lang.org/nightly/core/ptr/non_null/struct.NonNull.html" title="NonNull"><code>NonNull</code></a> which can use
up to <code>N</code> of its lower bits to store additional information (the <em>tag</em>).</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TagPtr.html" title="tagptr::TagPtr struct">TagPtr</a></div><div class="item-right docblock-short">A raw, unsafe pointer type like <code>*mut T</code> which can use up to <code>N</code> of its
lower bits to store additional information (the <em>tag</em>).</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.assert_alignment.html" title="tagptr::assert_alignment fn">assert_alignment</a></div><div class="item-right docblock-short">Asserts that the alignment of <code>U</code> is large enough so a pointer to an
instance may store <code>N</code> tag bits.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.has_sufficient_alignment.html" title="tagptr::has_sufficient_alignment fn">has_sufficient_alignment</a></div><div class="item-right docblock-short">Returns <code>true</code> if the alignment of <code>T</code> is large enough so a pointer to an
instance may store the given number of <code>tag_bits</code>.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="tagptr" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.0-nightly (61a415be5 2023-01-12)" data-search-js="search-181581080540673f.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-58836c674e2f7bd2.css" ></div></body></html>