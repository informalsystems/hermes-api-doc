initSidebarItems({"enum":[["HashOp",""],["LengthOp","LengthOp defines how to process the key and value of the LeafOp to include length information. After encoding the length with the given algorithm, the length will be prepended to the key and value bytes. (Each one with it’s own encoded length)"]],"fn":[["calculate_existence_root",""],["compress",""],["decompress",""],["iavl_spec",""],["is_compressed",""],["smt_spec",""],["tendermint_spec",""],["verify_batch_membership",""],["verify_batch_non_membership",""],["verify_membership",""],["verify_non_membership",""]],"mod":[["batch_entry","Nested message and enum types in `BatchEntry`."],["commitment_proof","Nested message and enum types in `CommitmentProof`."],["compressed_batch_entry","Nested message and enum types in `CompressedBatchEntry`."]],"struct":[["BatchEntry","Use BatchEntry not CommitmentProof, to avoid recursion"],["BatchProof","BatchProof is a group of multiple proof types than can be compressed"],["CommitmentProof","CommitmentProof is either an ExistenceProof or a NonExistenceProof, or a Batch of such messages"],["CompressedBatchEntry","Use BatchEntry not CommitmentProof, to avoid recursion"],["CompressedBatchProof",""],["CompressedExistenceProof",""],["CompressedNonExistenceProof",""],["ExistenceProof","ExistenceProof takes a key and a value and a set of steps to perform on it. The result of peforming all these steps will provide a “root hash”, which can be compared to the value in a header."],["HostFunctionsManager",""],["InnerOp","InnerOp represents a merkle-proof step that is not a leaf. It represents concatenating two children and hashing them to provide the next result."],["InnerSpec","InnerSpec contains all store-specific structure info to determine if two proofs from a given store are neighbors."],["LeafOp","LeafOp represents the raw key-value data we wish to prove, and must be flexible to represent the internal transformation from the original key-value pairs into the basis hash, for many existing merkle trees."],["NonExistenceProof","NonExistenceProof takes a proof of two neighbors, one left of the desired key, one right of the desired key. If both proofs are valid AND they are neighbors, then there is no valid proof for the given key."],["ProofSpec","ProofSpec defines what the expected parameters are for a given proof type. This can be stored in the client and used to validate any incoming proofs."]],"trait":[["HostFunctionsProvider","If this is to be executed in a blockchain context, then we need to delegate these hashing functions to a native implementation through host function calls. This trait provides that interface."]],"type":[["Hash",""],["Result",""]]});